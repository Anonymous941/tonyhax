diff --git a/tmp/og-tonyhax.Icq/loader/Makefile b/loader/Makefile
index f121ebf..7603534 100644
--- a/tmp/og-tonyhax.Icq/loader/Makefile
+++ b/loader/Makefile
@@ -32,7 +32,7 @@ secondary.elf: secondary.ld $(LOADER_OBJECTS)
 tonyhax.mcs: tonyhax-tpl.mcs secondary.elf
 	bash generate-tonyhax-mcs.sh secondary.elf tonyhax-tpl.mcs tonyhax.mcs $(TONYHAX_VERSION)
 
-BESLEM-99999TONYHAX: tonyhax.mcs
+HAX: tonyhax.mcs
 	bash ../util/mcs2raw.sh tonyhax.mcs
 
 tonyhax.exe: secondary.elf
diff --git a/loader/Makefile.ff9 b/loader/Makefile.ff9
new file mode 100644
index 0000000..cdfa377
--- /dev/null
+++ b/loader/Makefile.ff9
@@ -0,0 +1,39 @@
+
+# Thanks to whoever made https://devhints.io/makefile!
+
+include ../variables.mk
+
+LOADER_AUTOGEN := orca.inc
+LOADER_HEADERS := $(wildcard *.h) $(LOADER_AUTOGEN)
+LOADER_OBJECTS := $(patsubst %.c, %.o, $(patsubst %.S, %.o, $(wildcard *.c *.S)))
+
+all: $(LOADER_FILES)
+
+clean:
+	$(RM) $(LOADER_FILES) FF9 tonyhax-ff9.mcs *.o *.elf $(LOADER_AUTOGEN)
+
+# Intermediate objects
+
+%.o: %.c $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+%.o: %.S $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+orca.inc: orca.img
+	bash ../util/bin2h.sh ORCA_IMAGE orca.img orca.inc
+
+secondary.elf: secondary-ff9.ld $(LOADER_OBJECTS)
+	$(LD) $(LDFLAGS) -T secondary-ff9.ld $(LOADER_OBJECTS) -o $@
+	bash insert-tonyhax-crc.sh secondary.elf
+
+# Results
+
+tonyhax.mcs: tonyhax-tpl-ff9.mcs secondary.elf
+	bash generate-tonyhax-mcs.sh secondary.elf tonyhax-tpl-ff9.mcs tonyhax-ff9.mcs $(TONYHAX_VERSION)
+
+HAX: tonyhax.mcs
+	bash ../util/mcs2raw.sh tonyhax-ff9.mcs
+
+tonyhax.exe: secondary.elf
+	bash generate-tonyhax-exe.sh secondary.elf tonyhax.exe
diff --git a/loader/Makefile.freepsxboot b/loader/Makefile.freepsxboot
new file mode 100644
index 0000000..20b067a
--- /dev/null
+++ b/loader/Makefile.freepsxboot
@@ -0,0 +1,38 @@
+
+# Thanks to whoever made https://devhints.io/makefile!
+
+include ../variables.mk.freepsxboot
+
+LOADER_HEADERS := $(wildcard *.h) $(LOADER_AUTOGEN)
+LOADER_OBJECTS := $(patsubst %.c, %.o, $(patsubst %.S, %.o, $(wildcard *.c *.S)))
+
+all: $(LOADER_FILES)
+
+clean:
+	$(RM) $(LOADER_FILES) *.o *.elf $(LOADER_AUTOGEN)
+
+# Intermediate objects
+
+%.o: %.c $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+%.o: %.S $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+orca.inc: orca.img
+	bash ../util/bin2h.sh ORCA_IMAGE orca.img orca.inc
+
+secondary.elf: secondary.ld $(LOADER_OBJECTS)
+	$(LD) $(LDFLAGS) -T secondary.ld $(LOADER_OBJECTS) -o $@
+	bash insert-tonyhax-crc.sh secondary.elf
+
+# Results
+
+tonyhax.mcs: tonyhax-tpl.mcs secondary.elf
+	bash generate-tonyhax-mcs.sh secondary.elf tonyhax-tpl.mcs tonyhax.mcs $(TONYHAX_VERSION)
+
+HAX: tonyhax.mcs
+	bash ../util/mcs2raw.sh tonyhax.mcs
+
+tonyhax.exe: secondary.elf
+	bash generate-tonyhax-exe.sh secondary.elf tonyhax.exe
diff --git a/loader/Makefile.rom b/loader/Makefile.rom
new file mode 100644
index 0000000..162db42
--- /dev/null
+++ b/loader/Makefile.rom
@@ -0,0 +1,38 @@
+
+# Thanks to whoever made https://devhints.io/makefile!
+
+include ../variables.mk.rom
+
+LOADER_HEADERS := $(wildcard *.h) $(LOADER_AUTOGEN)
+LOADER_OBJECTS := $(patsubst %.c, %.o, $(patsubst %.S, %.o, $(wildcard *.c *.S)))
+
+all: $(LOADER_FILES)
+
+clean:
+	$(RM) $(LOADER_FILES) *.o *.elf $(LOADER_AUTOGEN)
+
+# Intermediate objects
+
+%.o: %.c $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+%.o: %.S $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+orca.inc: orca.img
+	bash ../util/bin2h.sh ORCA_IMAGE orca.img orca.inc
+
+secondary.elf: secondary.ld $(LOADER_OBJECTS)
+	$(LD) $(LDFLAGS) -T secondary.ld $(LOADER_OBJECTS) -o $@
+	bash insert-tonyhax-crc.sh secondary.elf
+
+# Results
+
+tonyhax.mcs: tonyhax-tpl.mcs secondary.elf
+	bash generate-tonyhax-mcs.sh secondary.elf tonyhax-tpl.mcs tonyhax.mcs $(TONYHAX_VERSION)
+
+HAX: tonyhax.mcs
+	bash ../util/mcs2raw.sh tonyhax.mcs
+
+tonyhax.exe: secondary.elf
+	bash generate-tonyhax-exe.sh secondary.elf tonyhax.exe
diff --git a/loader/Makefile.tocperfect b/loader/Makefile.tocperfect
new file mode 100644
index 0000000..d1582a2
--- /dev/null
+++ b/loader/Makefile.tocperfect
@@ -0,0 +1,38 @@
+
+# Thanks to whoever made https://devhints.io/makefile!
+
+include ../variables.mk.tocperfect
+
+LOADER_HEADERS := $(wildcard *.h) $(LOADER_AUTOGEN)
+LOADER_OBJECTS := $(patsubst %.c, %.o, $(patsubst %.S, %.o, $(wildcard *.c *.S)))
+
+all: $(LOADER_FILES)
+
+clean:
+	$(RM) $(LOADER_FILES) *.o *.elf $(LOADER_AUTOGEN)
+
+# Intermediate objects
+
+%.o: %.c $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+%.o: %.S $(LOADER_HEADERS)
+	$(CC) $(CFLAGS) -c $<
+
+orca.inc: orca.img
+	bash ../util/bin2h.sh ORCA_IMAGE orca.img orca.inc
+
+secondary.elf: secondary.ld $(LOADER_OBJECTS)
+	$(LD) $(LDFLAGS) -T secondary.ld $(LOADER_OBJECTS) -o $@
+	bash insert-tonyhax-crc.sh secondary.elf
+
+# Results
+
+tonyhax.mcs: tonyhax-tpl.mcs secondary.elf
+	bash generate-tonyhax-mcs.sh secondary.elf tonyhax-tpl.mcs tonyhax.mcs $(TONYHAX_VERSION)
+
+HAX: tonyhax.mcs
+	bash ../util/mcs2raw.sh tonyhax.mcs
+
+tonyhax.exe: secondary.elf
+	bash generate-tonyhax-exe.sh secondary.elf tonyhax.exe
diff --git a/loader/ap-bypass.c b/loader/ap-bypass.c
new file mode 100644
index 0000000..1795560
--- /dev/null
+++ b/loader/ap-bypass.c
@@ -0,0 +1,1577 @@
+
+#include "bios.h"
+//#include "debugscreen.h"
+#include "str.h"
+#include "ap-bypass.h"
+
+bool cheat_engine_installed;
+
+uint8_t gs_code_type;
+
+int32_t code_address_ram_location = 0xD000;
+int32_t code_compare_ram_location = 0xD004;
+int32_t code_enable_ram_location = 0xD00C;  
+
+void add_30_code(const uint32_t gs1, const uint8_t gs2) {
+	gs_code_type = 0x30;
+    memcpy((void*)code_address_ram_location, &gs1, 4);
+    memcpy((void*)code_compare_ram_location, &gs2, 1);
+    memcpy((void*)code_enable_ram_location, &gs_code_type, 1);
+// Update addresses to write to for an additional code
+	code_address_ram_location = (code_address_ram_location + 0x010);
+	code_compare_ram_location = (code_compare_ram_location + 0x010);
+	code_enable_ram_location = (code_enable_ram_location + 0x010);
+}
+
+void add_E0_code(const uint32_t gs1, const uint8_t gs2) {
+	gs_code_type = 0xE0;
+    memcpy((void*)code_address_ram_location, &gs1, 4);
+    memcpy((void*)code_compare_ram_location, &gs2, 1);
+    memcpy((void*)code_enable_ram_location, &gs_code_type, 1);
+// Update addresses to write to for an additional code
+	code_address_ram_location = (code_address_ram_location + 0x010);
+	code_compare_ram_location = (code_compare_ram_location + 0x010);
+	code_enable_ram_location = (code_enable_ram_location + 0x010);
+}
+
+void add_E1_code(const uint32_t gs1, const uint8_t gs2) {
+	gs_code_type = 0xE1;
+    memcpy((void*)code_address_ram_location, &gs1, 4);
+    memcpy((void*)code_compare_ram_location, &gs2, 1);
+    memcpy((void*)code_enable_ram_location, &gs_code_type, 1);
+// Update addresses to write to for an additional code
+	code_address_ram_location = (code_address_ram_location + 0x010);
+	code_compare_ram_location = (code_compare_ram_location + 0x010);
+	code_enable_ram_location = (code_enable_ram_location + 0x010);
+}
+
+void add_80_code(const uint32_t gs1, const uint16_t gs2) {
+	gs_code_type = 0x80;
+    memcpy((void*)code_address_ram_location, &gs1, 4);
+    memcpy((void*)code_compare_ram_location, &gs2, 2);
+    memcpy((void*)code_enable_ram_location, &gs_code_type, 1);
+// Update addresses to write to for an additional code
+	code_address_ram_location = (code_address_ram_location + 0x010);
+	code_compare_ram_location = (code_compare_ram_location + 0x010);
+	code_enable_ram_location = (code_enable_ram_location + 0x010);
+}
+
+void add_D0_code(const uint32_t gs1, const uint16_t gs2) {
+	gs_code_type = 0xD0;
+    memcpy((void*)code_address_ram_location, &gs1, 4);
+    memcpy((void*)code_compare_ram_location, &gs2, 2);
+    memcpy((void*)code_enable_ram_location, &gs_code_type, 1);
+// Update addresses to write to for an additional code
+	code_address_ram_location = (code_address_ram_location + 0x010);
+	code_compare_ram_location = (code_compare_ram_location + 0x010);
+	code_enable_ram_location = (code_enable_ram_location + 0x010);
+}
+
+void add_D1_code(const uint32_t gs1, const uint16_t gs2) {
+	gs_code_type = 0xD1;
+    memcpy((void*)code_address_ram_location, &gs1, 4);
+    memcpy((void*)code_compare_ram_location, &gs2, 2);
+    memcpy((void*)code_enable_ram_location, &gs_code_type, 1);
+// Update addresses to write to for an additional code
+	code_address_ram_location = (code_address_ram_location + 0x010);
+	code_compare_ram_location = (code_compare_ram_location + 0x010);
+	code_enable_ram_location = (code_enable_ram_location + 0x010);
+}
+
+void install_cheat_engine() {
+// generate with `scripts/stealth-engine-xxd.sh` after compiling .EXE file with No $ PSX Assembler
+const unsigned char cheat_engine_v1_0_2[] = {
+0xe0, 0xff, 0xbd, 0x27, 0x00, 0x00, 0xa4, 0xaf,
+  0x04, 0x00, 0xa5, 0xaf, 0x08, 0x00, 0xa6, 0xaf, 0x0c, 0x00, 0xa7, 0xaf,
+  0x00, 0x00, 0x04, 0x3c, 0x00, 0xd0, 0x84, 0x34, 0x00, 0x00, 0x00, 0x00,
+  0x0c, 0x00, 0x86, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x53, 0x00, 0xc0, 0x10,
+  0x30, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0xc7, 0x10,
+  0x80, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0xc7, 0x10,
+  0xe0, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x00, 0xc7, 0x10,
+  0xd0, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x27, 0x00, 0xc7, 0x10,
+  0xe1, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0xc7, 0x10,
+  0xd1, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00, 0x29, 0x00, 0xc7, 0x10,
+  0x30, 0x00, 0x07, 0x34, 0x1c, 0x00, 0x86, 0x8c, 0x00, 0x00, 0x00, 0x00,
+  0x2d, 0x00, 0xc7, 0x10, 0x80, 0x00, 0x07, 0x34, 0x00, 0x00, 0x00, 0x00,
+  0x2f, 0x00, 0xc7, 0x10, 0x04, 0x00, 0x85, 0x94, 0x00, 0x00, 0x87, 0x8c,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe5, 0xa4, 0x32, 0x00, 0x00, 0x18,
+  0x04, 0x00, 0x85, 0x90, 0x00, 0x00, 0x87, 0x8c, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0xe5, 0xa0, 0x2d, 0x00, 0x00, 0x18, 0x04, 0x00, 0x85, 0x90,
+  0x00, 0x00, 0x87, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x90,
+  0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0xc5, 0x14, 0x00, 0x00, 0x00, 0x00,
+  0xe7, 0xff, 0x00, 0x18, 0x04, 0x00, 0x85, 0x90, 0x00, 0x00, 0x87, 0x8c,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x90, 0x00, 0x00, 0x00, 0x00,
+  0x1c, 0x00, 0xc5, 0x10, 0x00, 0x00, 0x00, 0x00, 0xdf, 0xff, 0x00, 0x18,
+  0x04, 0x00, 0x85, 0x94, 0x00, 0x00, 0x87, 0x8c, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0xe6, 0x94, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0xc5, 0x14,
+  0x00, 0x00, 0x00, 0x00, 0xd7, 0xff, 0x00, 0x18, 0x04, 0x00, 0x85, 0x94,
+  0x00, 0x00, 0x87, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x94,
+  0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0xc5, 0x10, 0x00, 0x00, 0x00, 0x00,
+  0xcf, 0xff, 0x00, 0x18, 0x14, 0x00, 0x85, 0x90, 0x10, 0x00, 0x87, 0x8c,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe5, 0xa0, 0x05, 0x00, 0x00, 0x18,
+  0x14, 0x00, 0x85, 0x94, 0x10, 0x00, 0x87, 0x8c, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0xe5, 0xa4, 0x00, 0x00, 0x00, 0x18, 0x20, 0x00, 0x84, 0x24,
+  0xae, 0xff, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x84, 0x24,
+  0xab, 0xff, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa4, 0x8f,
+  0x04, 0x00, 0xa5, 0x8f, 0x08, 0x00, 0xa6, 0x8f, 0x0c, 0x00, 0xa7, 0x8f,
+  0x20, 0x00, 0xbd, 0x27, 0x01, 0x00, 0x1a, 0x3c, 0xfc, 0xcf, 0x5a, 0x8f,
+  0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00
+};
+
+	//debug_write("Installing MottZilla AP Engine");
+	memcpy((void*)0xC000, (void*)cheat_engine_v1_0_2, sizeof(cheat_engine_v1_0_2)); // Copy MottZilla's cheat engine assembly binary to 0xC000
+	const uint32_t b0_jump = (*(uint32_t*)0xB4) & 0xFFFF;
+	//debug_write("Got jump address for B0 functions : %x", (uint32_t) b0_jump);
+	const uint32_t b0_base = (*(uint32_t*)(b0_jump + 4)) & 0xFFFF;
+	//debug_write("Got base address for B0 table : %x", (uint32_t) b0_base);
+	const uint32_t b0_entry = b0_base + (0x17 * 4);
+	//debug_write("Got B0 table entry address : %x", (uint32_t) b0_entry);
+	const uint32_t old_table_val = *(uint32_t*) b0_entry;
+	//debug_write("B0 table entry to modify has the original contents : %x", (uint32_t) old_table_val);
+	memcpy((void*)0xCFFC, (void*)&old_table_val, sizeof(old_table_val)); // Copy the original 32 bit number of the B table entry we want to modify to 0xCFFC
+	const uint16_t redirect = 0xC000;
+	memcpy((void*)b0_entry, &redirect, 2); // Write the value 0xC000 to table entry we want to modify
+   //for(volatile int i = 0; i < 0x100000; i++);  // won't be optimized out by -Os, pause
+   cheat_engine_installed = 1;
+}
+
+void activate_anti_anti_piracy(const char * bootfile, const int32_t load_addr) 
+{
+	int32_t ver_check;
+	uint8_t ver_check_val;
+	int8_t bootfile_len = strlen(bootfile);
+
+	// Aprip code type constants
+	const uint16_t readtoc_compare_val = 0x001E;
+	const uint16_t readtoc_patch_val = 0x0000;
+
+	// Many pre-existing 'skip mod check' or 'force routine ok' type codes from back in the day seem to share these values, so they are a const
+	const uint16_t common_routine_return_compare_val = 0x1040;
+	const uint16_t common_routine_return_patch_val = 0x1000;
+
+	if(bootfile_len > 13) {
+		bootfile = &bootfile[bootfile_len-13]; // XXXX_XXX.XX;1 , we are only changing the locally declared bootfile here, not in secondary.c.
+		//debug_write("Stripped Bootfile: %s", bootfile);
+	} else if(bootfile_len < 13) {
+		return; 
+		// Speed optimization. All anti-piracy games currently have a bootfile name that is at least 13 uchars long when stripped. So if the bootfile happens to have something like 'MAIN.EXE;1' (which is 10 in length), we already know not to bother even checking for an anti-piracy bootfile match to apply codes for (which takes time in itself to do as well).
+	}
+
+// Animetic Story Game 1: Card Captor Sakura
+   	if(((strcmp("SLPS_018.30;1", bootfile)) == 0) || ((strcmp("SLPS_018.31;1", bootfile)) == 0)) { // 2 disc game
+   		//debug_write("Detected Animetic Story Game 1: Card Captor Sakura");
+		/*
+		D001516A 1040
+		8001516A 1000
+		code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_c.shtml
+    	*/
+    	add_D0_code(0x8001516A, common_routine_return_compare_val);
+		add_80_code(0x8001516A, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Alundra 2
+	((strcmp("SCPS_101.15;1", bootfile)) == 0) { 
+   		//debug_write("Detected Alundra 2 - Japan");
+		/*
+		D004E91A 1040
+		8004E91A 1000
+		'skip mod check' code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_a.shtml
+    	*/
+    	add_D0_code(0x8004E91A, common_routine_return_compare_val);
+		add_80_code(0x8004E91A, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Arc The Lad III
+	(((strcmp("SCPS_101.06;1", bootfile)) == 0) || ((strcmp("SCPS_101.07;1", bootfile)) == 0)) { // 2 Japan versions and each have 2 discs but the same codes per revision
+   		//debug_write("Detected Arc The Lad III - Japan");
+		ver_check = (load_addr + 0x20); // First different byte between revisions
+		//debug_write("Got address for version check: %x", (uint32_t) ver_check);
+		ver_check_val = *(uint8_t*) ver_check;
+		//debug_write("Ver check address has the contents : %x", (uint8_t) ver_check_val);
+		if((ver_check_val == 0x8C))
+		{
+			//debug_write("REV 0");
+			/*
+			D0021DF6 1040
+			80021DF6 1000
+			code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_a.shtml
+    		*/
+	    	add_D0_code(0x80021DF6, common_routine_return_compare_val);
+			add_80_code(0x80021DF6, common_routine_return_patch_val);
+    		install_cheat_engine();
+    	} else {
+			//debug_write("REV 1");
+ 			/*
+			D0022206 1040 my code via aprip gameshark code conversion
+			80022206 1000
+    		*/
+	    	add_D0_code(0x80022206, common_routine_return_compare_val);
+			add_80_code(0x80022206, common_routine_return_patch_val);
+    		install_cheat_engine();		
+    	}
+    } else if
+
+// Beatmania featuring Dreams Come True
+   	((strcmp("SLPM_865.97;1", bootfile)) == 0) {
+   		//debug_write("Beatmania featuring Dreams Come True");
+		/*
+		D012255C 001E
+		8012255C 0000
+		code generated via aprip by https://www.psx-place.com/members/trappedinlimbo.156719/
+    	*/
+	    add_D0_code(0x8012255C, readtoc_compare_val);
+		add_80_code(0x8012255C, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Beatmania Best Hits
+   	((strcmp("Slpm_865.96;1", bootfile)) == 0) { // 2 different versions, same code works on both rev 0 and rev 1
+   		//debug_write("Detected Beatmania Best Hits");
+		/*
+		D0151448 001E
+		80151448 0000
+		code generated via aprip by https://www.psx-place.com/members/trappedinlimbo.156719/
+    	*/
+	    add_D0_code(0x80151448, readtoc_compare_val);
+		add_80_code(0x80151448, readtoc_patch_val);
+    	install_cheat_engine();
+	} else if
+
+// Beat Mania: The Sound of Tokyo
+	((strcmp("SLPM_867.69;1", bootfile)) == 0) { 
+   		//debug_write("Detected Beat Mania - The Sound of Tokyo");
+    	/*
+		D0134C48 001E
+		80134C48 0000
+		my code to patch out readtoc
+    	*/
+	    add_D0_code(0x80134C48, readtoc_compare_val);
+		add_80_code(0x80134C48, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Beat Mania 6thMix + Core Remix
+	((strcmp("SLPM_870.12;1", bootfile)) == 0) { 
+   		//debug_write("Detected Beat Mania 6th Mix + Core Remix");
+		/*
+		D0131B6C 001E
+		80131B6C 001A
+    	my code to patch out readtoc
+    	*/
+	    add_D0_code(0x80131B6C, readtoc_compare_val);
+		add_80_code(0x80131B6C, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Biohazard 3: The Last Escape
+   	((strcmp("SLPS_023.00;1", bootfile)) == 0) { // 2 different versions
+   		//debug_write("Detected Biohazard 3 - Japan");
+		ver_check = (load_addr + 0x1B0); // First different byte between revisions
+		//debug_write("Got address for version check: %x", (uint32_t) ver_check);
+		ver_check_val = *(uint8_t*) ver_check;
+		//debug_write("Ver check address has the contents : %x", (uint8_t) ver_check_val);
+		if((ver_check_val == 0xF4))
+		{
+			//debug_write("REV 0");
+			/*
+			D01840E2 1040
+			801840E2 1000
+			'skip check' code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_b.shtml
+    		*/
+	    	add_D0_code(0x801840E2, common_routine_return_compare_val);
+			add_80_code(0x801840E2, common_routine_return_patch_val);
+    		install_cheat_engine();
+	    } else {
+			//debug_write("REV 1");
+			/*
+			D018418E 1040
+			8018418E 1000 
+			my code via aprip gameshark code conversion
+    		*/
+	    	add_D0_code(0x8018418E, common_routine_return_compare_val);
+			add_80_code(0x8018418E, common_routine_return_patch_val);
+    		install_cheat_engine();
+	    }
+	} else if
+
+   	((strcmp("SLPM_804.85;1", bootfile)) == 0) { // Demo
+   		//debug_write("Detected Bio Hazard 3 Demo");
+		/*
+		D01800E2 1040
+		801800E2 1000 
+		my code via aprip gameshark code conversion
+    	*/
+	    add_D0_code(0x801800E2, common_routine_return_compare_val);
+		add_80_code(0x801800E2, common_routine_return_patch_val);
+    	install_cheat_engine();
+	} else if
+
+// Chase The Express
+   	(((strcmp("SCPS_101.09;1", bootfile)) == 0) || ((strcmp("SCPS_101.10;1", bootfile)) == 0) || ((strcmp("PAPX_901.06;1", bootfile)) == 0) || ((strcmp("PCPX_961.89;1", bootfile)) == 0)) { // 2 discs and 2 demos all share the same code
+   		//debug_write("Detected Chase The Express - Japan");
+		/*
+		D00EA6DE 1040
+		800EA6DE 1000
+		'skip mod check' code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_c.shtml
+    	*/
+	    add_D0_code(0x800EA6DE, common_routine_return_compare_val);
+		add_80_code(0x800EA6DE, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Crash Bash
+  	((strcmp("SCUS_945.70;1", bootfile)) == 0) {
+   		//debug_write("Detected Crash Bash - USA");
+		/*
+		D002D51E 1040
+		8002D51E 1000
+		code from GameHacking: https://gamehacking.org/game/88640, skips mod check
+    	*/
+	    add_D0_code(0x8002D51E, common_routine_return_compare_val);
+		add_80_code(0x8002D51E, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if 
+
+   	((strcmp("SCPS_101.40;1", bootfile)) == 0) {
+   		//debug_write("Detected Crash Bash - Japan");
+		/*
+		D002D7EE 1040
+		8002D7EE 1000
+		code from GameHacking: https://gamehacking.org/game/93827, skips mod check
+    	*/
+	    add_D0_code(0x8002D7EE, common_routine_return_compare_val);
+		add_80_code(0x8002D7EE, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Crash Bandicoot Racing
+   	((strcmp("SCPS_101.18;1", bootfile)) == 0) {
+   		//debug_write("Detected Crash Bandicoot Racing");
+		/*
+		D001259A 1040
+		8001259A 1000
+		'skip mod check' code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_b.shtml (yes it's on the wrong lettered page)
+    	*/
+	    add_D0_code(0x8001259A, common_routine_return_compare_val);
+		add_80_code(0x8001259A, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+   	((strcmp("PCPX_961.83;1", bootfile)) == 0) {
+   		//debug_write("Detected Crash Bandicoot Racing Demo");
+		/*
+    	D001255E 1040
+    	8001255E 1040
+		my code via aprip gameshark code conversion
+    	*/
+	    add_D0_code(0x8001255E, common_routine_return_compare_val);
+		add_80_code(0x8001255E, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Cool Boarders 2001
+   	((strcmp("SCUS_946.25;1", bootfile)) == 0) {
+   		//debug_write("Detected Cool Boarders 2001 - USA Demo");
+		/*
+		D00B35B0 001E
+		800B35B0 0000
+		code generated via aprip
+    	*/
+	    add_D0_code(0x800B35B0, readtoc_compare_val);
+		add_80_code(0x800B35B0, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+   	((strcmp("SCUS_945.97;1", bootfile)) == 0) {
+   		//debug_write("Detected Cool Boarders 2001 - USA");
+		/*
+		D00B35B8 001E
+		800B35B8 0000
+		my code via aprip gameshark code conversion
+    	*/
+	    add_D0_code(0x800B35B8, readtoc_compare_val);
+		add_80_code(0x800B35B8, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution: Best Hits
+   	((strcmp("SLPM_866.93;1", bootfile)) == 0) {
+   		//debug_write("Detected Dance Dance Revolution: Best Hits");
+		/*
+		D0102FA0 001E
+		80102FA0 0000
+		my code generated via aprip
+    	*/
+	    add_D0_code(0x80102FA0, readtoc_compare_val);
+		add_80_code(0x80102FA0, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution: Disney's Rave
+   	((strcmp("SLPM_866.67;1", bootfile)) == 0) {
+   		//debug_write("Detected Dance Dance Revolution: Disney's Rave");
+		/*
+		D0192248 001E
+		80192248 0000
+		code generated via aprip by https://www.psx-place.com/members/trappedinlimbo.156719/
+    	*/
+	    add_D0_code(0x80192248, readtoc_compare_val);
+		add_80_code(0x80192248, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution: Extra Mix
+   	((strcmp("SLPM_868.31;1", bootfile)) == 0) {
+   		//debug_write("Detected Dance Dance Revolution: Extra Mix");
+		/*
+		D00EB364 001E
+		800EB364 0000
+		code generated via aprip by https://www.psx-place.com/members/trappedinlimbo.156719/
+    	*/
+	    add_D0_code(0x800EB364, readtoc_compare_val);
+		add_80_code(0x800EB364, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dance Dance Revolution 2nd Remix / Dance Dance Revolution 2nd Remix Append Club Vol 1 / Dance Dance Revolution 2nd Remix Append Club Vol 2
+   	((strcmp("SLPM_862.52;1", bootfile)) == 0) { // Dance Dance Revolution 2nd Remix Append Club Vol 1 and Dance Dance Revolution 2nd Remix Append Club Vol 2 discs are booted with a 'disc change' feature within Dance Dance Revolution 2nd Remix (which is a 'base' disc when booting the others, kind of like DLC).
+   		//debug_write("Detected Dance Dance Revolution 2nd Remix");
+		/*
+		Dance Dance Revolution 2nd Remix:
+		D00200A6 1040
+		800200A6 1000
+		*/
+	    add_D0_code(0x800200A6, common_routine_return_compare_val);
+		add_80_code(0x800200A6, common_routine_return_patch_val);
+		/*
+		D0020D64 FFF2
+		80020D64 0001
+		*/
+    	add_D0_code(0x80020D64, 0xFFF2);
+    	add_80_code(0x80020D64, 0x0001);
+		/*
+		D01C1BE4 FFF2
+		801C1BE4 0001
+		*/
+    	add_D0_code(0x801C1BE4, 0xFFF2);
+    	add_80_code(0x801C1BE4, 0x0001);
+
+		/*
+		D01C1C7A 0C07
+		801C1C7A 3002
+		*/
+    	add_D0_code(0x801C1C7A, 0x0C07);
+    	add_80_code(0x801C1C7A, 0x3002);
+		/*
+		D01C2936 1040
+		801C2936 1000
+		*/
+    	add_D0_code(0x801C2936, common_routine_return_compare_val);
+    	add_80_code(0x801C2936, common_routine_return_patch_val);
+		/*
+		Dance Dance Revolution 2nd Remix Append Club Vol 1
+		D01C2A18 0C92
+		801C2A18 0AA7
+		*/
+    	add_D0_code(0x801C2A18, 0x0C92);
+    	add_80_code(0x801C2A18, 0x0AA7);
+		/*
+		D01C2EA2 1040
+		801C2EA2 1000
+		*/
+    	add_D0_code(0x801C2EA2,common_routine_return_compare_val);
+    	add_80_code(0x801C2EA2, common_routine_return_patch_val);
+
+		/*
+		Dance Dance Revolution 2nd Remix Append Club Vol 2
+		D01C2F32 1040
+		801C2F32 1000
+		*/
+    	add_D0_code(0x801C2F32, common_routine_return_compare_val);
+    	add_80_code(0x801C2F32, common_routine_return_patch_val);
+		/*
+		D01C2AA8 0CB6
+		801C2AA8 0ACB
+		*/
+    	add_D0_code(0x801C2AA8, 0x0CB6);
+    	add_80_code(0x801C2AA8, 0x0ACB);
+		// codes are from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_d.shtml . There are EDC releated codes provided, but they don't seem to actually work (another EDC check still prevents the game from fully starting) and we are not providing EDC bypasses as they can be circumvented by burning CD-Rs as raw without regnerating the EDC.
+    	install_cheat_engine();
+    } else if
+
+// Dancing Stage featuring Dreams Come True
+   	((strcmp("SLPM_865.05;1", bootfile)) == 0) {
+   		//debug_write("Detected Dancing Stage featuring Dreams Come True");
+		/*
+		D019245C 001E
+		8019245C 0000
+		code generated via aprip by https://www.psx-place.com/members/trappedinlimbo.156719/
+    	*/
+    	add_D0_code(0x8019245C, readtoc_compare_val);
+    	add_80_code(0x8019245C, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Dancing Stage featuring True Kiss Destination
+   	((strcmp("SLPM_864.11;1", bootfile)) == 0) {
+   		//debug_write("Detected Dancing Stage featuring True Kiss Destination");
+		/*
+		D019117A 1040
+		8019117A 1000
+		code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_d.shtml
+    	*/
+    	add_D0_code(0x8019117A, common_routine_return_compare_val);
+    	add_80_code(0x8019117A, common_routine_return_patch_val);
+
+    	install_cheat_engine();
+    } else if
+
+// Dino Crisis
+	((strcmp("SLUS_009.22;1", bootfile)) == 0) { // NTSC-U has 2 versions, rev 0 and rev 1 (greatest hits) see https://tcrf.net/Dino_Crisis_(PlayStation)#Revisional_Differences
+		//debug_write("Detected Dino Crisis - USA");
+		ver_check = (load_addr + 0x61); // First different byte between revisions
+		//debug_write("Got address for version check: %x", (uint32_t) ver_check);
+		ver_check_val = *(uint8_t*) ver_check;
+		//debug_write("Ver check address has the contents : %x", (uint8_t) ver_check_val);
+		if((ver_check_val == 0xD0)) {
+			//debug_write("Rev 0");
+			/*
+			D0149004 959C
+			80149004 9E64
+			Found independently by MottZilla, but actually turns out to be the same code by Epson found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_d.shtml
+			*/
+  		  	add_D0_code(0x80149004, 0x959C);
+  		  	add_80_code(0x80149004, 0x9E64);
+			install_cheat_engine();
+		} else {
+			//debug_write("Rev 1");
+			/*
+			D0148004 8658
+			80148004 8F20
+			my code, the anti-piracy table just moved memory addresses between versions :)
+			*/
+ 			add_D0_code(0x80148004, 0x8658);
+ 			add_80_code(0x80148004, 0x8F20);
+			install_cheat_engine();
+    	}
+	} else if
+
+   	((strcmp("SLPS_021.80;1", bootfile)) == 0) { // Same as USA Rev 0
+   		//debug_write("Detected Dino Crisis - Japan");
+		/*
+		D0149004 959C
+		80149004 9E64
+		Found independently by MottZilla, but actually turns out to be the same code by Epson found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_d.shtml . Yes this is the same code as the USA rev 0 one.
+		*/
+  		add_D0_code(0x80149004, 0x959C);
+  		add_80_code(0x80149004, 0x9E64);
+		install_cheat_engine();
+    } else if
+
+// Dino Crisis 2
+   	((strcmp("SLPM_866.27;1", bootfile)) == 0) {
+   		//debug_write("Detected Dino Crisis 2 - Japan");
+	  	/*
+		D00D7714 001E
+		800D7714 0000
+		my code via aprip to disable readtoc
+		*/
+		add_D0_code(0x800D7714, readtoc_compare_val);
+		add_80_code(0x800D7714, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	((strcmp("SLPM_805.73;1", bootfile)) == 0) {
+   		//debug_write("Detected Dino Crisis 2 - Japan Demo");
+	  		/*
+		D00CB104 001E
+		800CB104 0000
+		my codevia aprip to disable readtoc
+		*/
+		add_D0_code(0x800CB104, readtoc_compare_val);
+		add_80_code(0x800CB104, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Disney's The Emperor's New Groove
+   	((strcmp("SCUS_945.71;1", bootfile)) == 0) {
+   		//debug_write("Detected Disney's The Emperor's New Groove - USA");
+	  		/*
+		D0063004 001E
+		80063004 0000
+		my code via aprip to disable readtoc
+		*/
+		add_D0_code(0x80063004, readtoc_compare_val);
+		add_80_code(0x80063004, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	((strcmp("SCES_030.10;1", bootfile)) == 0) {
+   		//debug_write("Detected Disney's The Emperor's New Groove - EUR");
+	  		/*
+		D006351C 001E
+		8006351C 0000
+		my code via aprip to disable readtoc
+		*/
+		add_D0_code(0x8006351C, readtoc_compare_val);
+		add_80_code(0x8006351C, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Exciting Bass 2
+   	((strcmp("SLPM_862.95;1", bootfile)) == 0) {
+   		//debug_write("Detected Exciting Bass 2");
+		/*
+		D00177BA 1040
+		800177BA 1000	
+		code found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_e.shtml
+  		*/
+  		add_D0_code(0x800177BA, common_routine_return_compare_val);
+  		add_80_code(0x800177BA, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Exciting Bass 3
+   	((strcmp("SLPM_867.29;1", bootfile)) == 0) {
+   		//debug_write("Detected Exciting Bass 3");
+		/*
+		D00B9170 001E
+		800B9170 0000
+		my code to patch out readtoc via aprip
+  		*/
+		add_D0_code(0x800B9170, readtoc_compare_val);
+		add_80_code(0x800B9170, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Gekitotsu Toma L'Arc - L'Arc en Ciel vs Tomarunner
+   	((strcmp("SCPS_101.34;1", bootfile)) == 0) {
+   		//debug_write("Detected Gekitotsu Toma L'Arc - L'Arc en Ciel vs Tomarunner");
+		/*
+		D0195D9C 001E
+		80195D9C 0000
+		my code to patch out readtoc via aprip
+  		*/
+		add_D0_code(0x80195D9C, readtoc_compare_val);
+		add_80_code(0x80195D9C, readtoc_patch_val);
+  		install_cheat_engine();
+    } else if
+
+// Goo! Goo! Soundry
+   	((strcmp("SLPM_862.50;1", bootfile)) == 0) {
+   		//debug_write("Detected Goo Goo Soundry");
+		/*
+		D0055278 001E
+		80055278 0000
+		my code to patch out readtoc via aprip
+  		*/
+		add_D0_code(0x80055278, readtoc_compare_val);
+		add_80_code(0x80055278, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Grind Session
+   	((strcmp("SCUS_945.68;1", bootfile)) == 0) {
+   		//debug_write("Detected Grind Session");
+		/*
+		D0014274 52A9
+		80014274 50BE
+		code 1 of 2 by 'TheVoice' found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_g.shtml
+    	*/
+  		add_D0_code(0x80014274, 0x52A9);
+  		add_80_code(0x80014274, 0x50BE);
+		/*
+		D00146FE 1040
+		800146FE 1000
+		code 2 of 2 by 'TheVoice' found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_g.shtml
+		*/
+  		add_D0_code(0x800146FE, common_routine_return_compare_val);
+  		add_80_code(0x800146FE, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Guitar Freaks
+   	((strcmp("SLPM_862.65;1", bootfile)) == 0) {
+   		//debug_write("Detected Guitar Freaks");
+		/*
+		D001654E 1040
+		8001654E 1000
+		code found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_g.shtml
+    	*/
+  		add_D0_code(0x8001654E, common_routine_return_compare_val);
+  		add_80_code(0x8001654E, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Harlem Beat: You're The One
+   	((strcmp("SLPM_863.29;1", bootfile)) == 0) {
+   		//debug_write("Detected Harlem Beat");
+		/*
+		D01A411E 1040
+		801A411E 1000
+		code found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_h.shtml
+    	*/
+  		add_D0_code(0x801A411E, common_routine_return_compare_val);
+  		add_80_code(0x801A411E, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Hyper Value 2800: Mahjong
+   	((strcmp("SLPM_862.92;1", bootfile)) == 0) {
+   		//debug_write("Detected Hyper Value 2800 Mahjong");
+		/*
+		D00A0186 1040
+		800A0186 1000
+		code found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_h.shtml
+    	*/
+  		add_D0_code(0x800A0186, common_routine_return_compare_val);
+  		add_80_code(0x800A0186, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// i-mode mo Issho: Doko Demo Issho Tsuika Disc
+    ((strcmp("SCPS_101.41;1", bootfile)) == 0) {
+        //debug_write("Detected i-mode mo Issho: Doko Demo Issho Tsuika Disc");
+        /*
+        D01698B4 001E
+        801698B4 0000
+        code generated via aprip by M4x1mumReZ: https://gbatemp.net/members/m4x1mumrez.610331/
+        */
+        add_D0_code(0x801698B4, readtoc_compare_val);
+        add_80_code(0x801698B4, readtoc_patch_val);
+        install_cheat_engine();
+    } else if
+
+// Jikkyou Powerful Pro Yakyuu '99 Ketteiban
+   	((strcmp("SLPM_864.33;1", bootfile)) == 0) {
+   		//debug_write("Detected Jikkyou Powerful Pro Yakyuu '99 Ketteiban");
+	  		/*
+		D016B4D8 001E
+		8016B4D8 0000
+		my code to patch out readtoc via aprip
+		*/
+        add_D0_code(0x8016B4D8, readtoc_compare_val);
+        add_80_code(0x8016B4D8, readtoc_patch_val);
+		install_cheat_engine();
+	} else if
+
+// Jikkyou Powerful Pro Yakyuu '99: Kaimakuban
+   	((strcmp("SLPM_862.53;1", bootfile)) == 0) {
+   		//debug_write("Detected Jikkyou Powerful Pro Yakyuu '99 Kaimakuban");
+		/*
+		D016B268 001E
+		8016B268 0000
+		my code to patch out readtoc via aprip
+		*/
+        add_D0_code(0x8016B268, readtoc_compare_val);
+        add_80_code(0x8016B268, readtoc_patch_val);
+		install_cheat_engine();
+	} else if
+
+// JoJo's Bizarre Adventure
+   	((strcmp("SLPS_022.36;1", bootfile)) == 0) {
+   		//debug_write("Detected JoJo's Bizarre Adventure");
+		/*
+		D0035C48 D91E
+		80035C48 D733
+		code 1 of 2 found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_j.shtml
+    	*/
+  		add_D0_code(0x80035C48, 0xD91E);
+  		add_80_code(0x80035C48, 0xD733);
+  		/*
+		D00360D2 1040
+		800360D2 1000
+		code 2 of 2 found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_j.shtml
+    	*/
+  		add_D0_code(0x800360D2, common_routine_return_compare_val);
+  		add_80_code(0x800360D2, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Koko Hore! Pukka
+	((strcmp("SCPS_101.33;1", bootfile)) == 0) {
+		//debug_write("Detected Kore Hore! Pukka");
+		/*
+		D00A341C 001E
+		800A341C 0000
+		code generated via aprip by https://gbatemp.net/members/m4x1mumrez.610331/
+    	*/
+  		add_D0_code(0x800A341C, readtoc_compare_val);
+  		add_80_code(0x800A341C, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Koneko mo Issho
+   	((strcmp("SCPS_101.27;1", bootfile)) == 0) {
+   		//debug_write("Detected Koneko mo Issho");
+		/*
+		D016957C 001E
+		8016957C 0000
+		my code generated via aprip
+		*/
+  		add_D0_code(0x8016957C, readtoc_compare_val);
+  		add_80_code(0x8016957C, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Legend Of Dragoon
+   	(((strcmp("SCPS_101.19;1", bootfile)) == 0) || ((strcmp("scps_101.20;1", bootfile)) == 0) || ((strcmp("scps_101.21;1", bootfile)) == 0) || ((strcmp("scps_101.22;1", bootfile)) == 0)) { // 4 discs
+   		//debug_write("Detected Legend Of Dragoon - Japan");
+		/*
+		D01BF172 1040
+		801BF172 1000
+		code found on consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_l.shtml
+    	*/
+  		add_D0_code(0x801BF172, common_routine_return_compare_val);
+  		add_80_code(0x801BF172, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	(((strcmp("SCUS_944.91;1", bootfile)) == 0) || ((strcmp("SCUS_945.84;1", bootfile)) == 0) || ((strcmp("SCUS_945.85;1", bootfile)) == 0) || ((strcmp("SCUS_945.86;1", bootfile)) == 0)) { // 4 discs
+   		//debug_write("Detected Legend Of Dragoon - USA");
+		/*
+		801BF6F6 1040
+		801BF6F6 1000 
+		my code via aprip's gameshark conversion
+   		*/
+  		add_D0_code(0x801BF6F6, common_routine_return_compare_val);
+  		add_80_code(0x801BF6F6, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	(((strcmp("SCES_030.43;1", bootfile)) == 0) || ((strcmp("SCES_130.43;1", bootfile)) == 0) || ((strcmp("SCES_230.43;1", bootfile)) == 0) || ((strcmp("SCES_330.43;1", bootfile)) == 0)) { // 4 discs
+   		//debug_write("Detected Legend Of Dragoon - EUR");
+		/*
+		D01C0892 1040
+		801C0892 1000
+		my code via aprip's gameshark conversion
+		*/
+  		add_D0_code(0x801C0892, common_routine_return_compare_val);
+  		add_80_code(0x801C0892, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	(((strcmp("SCES_030.44;1", bootfile)) == 0) || ((strcmp("SCES_130.44;1", bootfile)) == 0) || ((strcmp("SCES_230.44;1", bootfile)) == 0) || ((strcmp("SCES_330.44;1", bootfile)) == 0)) { // 4 discs
+   		//debug_write("Detected Legend Of Dragoon - FRA");
+		/*
+		D01C0872 1040
+		801C0872 1040
+		my code via aprip's gameshark conversion
+		*/
+  		add_D0_code(0x801C0872, common_routine_return_compare_val);
+  		add_80_code(0x801C0872, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	(((strcmp("SCES_030.45;1", bootfile)) == 0) || ((strcmp("SCES_130.45;1", bootfile)) == 0) || ((strcmp("SCES_230.45;1", bootfile)) == 0) || ((strcmp("SCES_330.45;1", bootfile)) == 0)) { // 4 discs
+   		//debug_write("Detected Legend Of Dragoon - GER");
+		/*
+		D01C082E 1040
+		801C082E 1000
+		my code via aprip's gameshark conversion
+  		*/
+  		add_D0_code(0x801C082E, common_routine_return_compare_val);
+  		add_80_code(0x801C082E, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	(((strcmp("SCES_030.46;1", bootfile)) == 0) || ((strcmp("SCES_130.46;1", bootfile)) == 0) || ((strcmp("SCES_230.46;1", bootfile)) == 0) || ((strcmp("SCES_330.46;1", bootfile)) == 0)) { // 4 discs
+   		//debug_write("Detected Legend Of Dragoon - ITA");
+		/*
+		D01C0826 1040
+		801C0826 1000
+		my code via aprip's gameshark conversion
+		*/
+  		add_D0_code(0x801C0826, common_routine_return_compare_val);
+  		add_80_code(0x801C0826, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Legend Of Mana
+   	((strcmp("SLPS_021.70;1", bootfile)) == 0) { // Japan
+   		//debug_write("Detected Legend Of Mana");
+		/*
+		D0050ECA 1040 
+		80050ECA 1000
+		code 1 of 2 from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_l.shtml
+		*/
+  		add_D0_code(0x80050ECA, common_routine_return_compare_val);
+  		add_80_code(0x80050ECA, common_routine_return_patch_val);
+    	/*
+		D00360D2 1040
+		800360D2 1000
+		code 2 of 2 from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_l.shtml
+		*/
+  		add_D0_code(0x800360D2, common_routine_return_compare_val);
+  		add_80_code(0x800360D2, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Love Hina: Ai wa Kotoba no Naka ni / Love Hina 2: Kotoba wa Konayuki no You ni
+   	(((strcmp("SLPM_866.52;1", bootfile)) == 0) || ((strcmp("SLPM_866.77;1", bootfile)) == 0)) { // Same code works for both games
+   		//debug_write("Detected Love Hina 1 or 2");
+		/*
+		 D01011C0 001E
+		 801011C0 0000
+		code generated via APrip by https://gbatemp.net/members/m4x1mumrez.610331/
+    	*/
+ 		add_D0_code(0x801011C0, readtoc_compare_val);
+ 		add_80_code(0x801011C0, readtoc_patch_val);
+ 		install_cheat_engine();
+    } else if
+
+// Marvel vs. Capcom: Clash of Super Heroes
+   	(((strcmp("SLPS_023.68;1", bootfile)) == 0) || ((strcmp("SLPM_805.08;1", bootfile)) == 0)) { // Japan/Japan Demo share same code
+   		//debug_write("Detected Marvel vs. Capcom Clash of Super Heroes");
+		/*
+		D00F0C3A 1040
+		800F0C3A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_m.shtml
+    	*/
+  		add_D0_code(0x800F0C3A, common_routine_return_compare_val);
+  		add_80_code(0x800F0C3A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Medievil II
+   	((strcmp("SCUS_945.64;1", bootfile)) == 0) {
+   		//debug_write("Detected MediEvil II USA");
+		/*
+		D00E1A58 001E
+		800E1A58 0000
+		my code generated via aprip
+		*/
+  		add_D0_code(0x800E1A58, readtoc_compare_val);
+  		add_80_code(0x800E1A58, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// MLB 2002 Demo, MLB 2002, MLB 2003 Demo, MLB 2003, MLB 2004
+   	(((strcmp("SCUS_946.48;1", bootfile)) == 0) || ((strcmp("SCUS_946.38;1", bootfile)) == 0) || ((strcmp("SCUS_946.72;1", bootfile)) == 0) || ((strcmp("SCUS_946.53;1", bootfile)) == 0) || ((strcmp("SCUS_946.89;1", bootfile)) == 0)) {
+   		//debug_write("Detected MLB 2002-2004");
+		/*
+		D0028DB4 001E
+		80028DB4 0000
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x80028DB4, readtoc_compare_val);
+  		add_80_code(0x80028DB4, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// My Garden
+   	((strcmp("SLPS_022.13;1", bootfile)) == 0) {
+   		//debug_write("Detected My Garden");
+		/*
+		D009E212 1040
+		8009E212 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_m.shtml
+    	*/
+  		add_D0_code(0x8009E212, common_routine_return_compare_val);
+  		add_80_code(0x8009E212, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// NBA Shootout 2001 and NBA Shootout 2001 Demo
+   	((strcmp("SCUS_945.81;1", bootfile)) == 0) { // this game is nuts. Seriously what the fuck is this. The demo and retail versions share not only the same executable filename, the demo executable file is the exact same with 0 diffs compared to the retail version. I guess retail functionallity is being enabled by some other file in track 01 (which do in fact differ between the demo and retail versions). EVEN FUCKING WORSE is that the demo version has serial number SCUS_945.82, but the boot file is SCUS_945.81! For now we enable both demo and retail codes for both versions to ensure it boots, since we can't detect this off of bootfile alone. To do this in a less ugly way we would need to find the file in track 01 that differs (to enable retail functionallity) and then diff that in memory.
+		/*
+		D01D1340 001E
+		801D1340 0000
+		my code generated via aprip (retail)
+		*/
+		add_D0_code(0x801D1340, readtoc_compare_val);
+		add_80_code(0x801D1340, readtoc_patch_val);
+		/*
+		D01CFD68 001E
+		801CFD68 0000
+		my code generated via aprip (demo)
+		*/
+		add_D0_code(0x801CFD68, readtoc_compare_val);
+		add_80_code(0x801CFD68, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// NBA Shootout 2002 Demo
+   	((strcmp("SCUS_946.60;1", bootfile)) == 0) {
+		//debug_write("Detected NBA Shootout 2002 Demo");
+		/*
+		D01D0FF4 001E
+		801D0FF4 0000
+		my code generated via aprip
+		*/
+		add_D0_code(0x801D0FF4, readtoc_compare_val);
+		add_80_code(0x801D0FF4, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// NBA Shootout 2002
+   	((strcmp("SCUS_946.41;1", bootfile)) == 0) {
+		//debug_write("Detected NBA Shootout 2002");
+		/*
+		D01D2724 001E
+		801D2724 0000
+		my code generated via aprip
+		*/
+		add_D0_code(0x801D2724, readtoc_compare_val);
+		add_80_code(0x801D2724, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// NBA Shootout 2003
+   	((strcmp("SCUS_946.73;1", bootfile)) == 0) {
+		//debug_write("Detected NBA Shootout 2003");
+		/*
+		D01D2860 001E
+		801D2860 0000
+		my code generated via aprip
+		*/
+		add_D0_code(0x801D2860, readtoc_compare_val);
+		add_80_code(0x801D2860, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// NBA Shootout 2004
+   	((strcmp("SCUS_946.91;1", bootfile)) == 0) {
+		//debug_write("Detected NBA Shootout 2003");
+		/*
+		D01D2928 001E
+		801D2928 0000
+		my code generated via aprip
+		*/
+		add_D0_code(0x801D2928, readtoc_compare_val);
+		add_80_code(0x801D2928, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// NCAA FinalFour 2001
+   	((strcmp("SCUS_945.79;1", bootfile)) == 0) {
+   		//debug_write("Detected NCAA Final Four 2001");
+		/*
+		D005B6A8 001E
+		8005B6A8 0000
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x8005B6A8, readtoc_compare_val);
+  		add_80_code(0x8005B6A8, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// NCAA GameBreaker 2001 and NCAA GameBreaker 2001 Demo
+   	(((strcmp("SCUS_945.74;1", bootfile)) == 0) || ((strcmp("SCUS_945.73;1", bootfile)) == 0)) {
+   		//debug_write("Detected NCAA GameBreaker 2001 or NCAA GameBreaker 2001 Demo");
+		/*
+		D0112338 001E
+		80112338 0000
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x80112338, readtoc_compare_val);
+  		add_80_code(0x80112338, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// NFL GameDay 2001
+   	((strcmp("SCUS_945.75;1", bootfile)) == 0) {
+   		//debug_write("Detected NFL GameDay 2001");
+		/*
+		D0112404 001E
+		80112404 0000
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x80112404, readtoc_compare_val);
+  		add_80_code(0x80112404, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// NFL GameDay 2001 Demo
+   	((strcmp("SCUS_945.76;1", bootfile)) == 0) {
+   		//debug_write("Detected NFL GameDay 2001 Demo");
+		/*
+		D0112388 001E
+		80112388 0000
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x80112388, readtoc_compare_val);
+  		add_80_code(0x80112388, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// NFL GameDay 2002
+   	((strcmp("SCUS_946.39;1", bootfile)) == 0) {
+   		//debug_write("Detected NFL GameDay 2002");
+		/*
+		D0032640 001E
+		80032640 0000
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x80032640, readtoc_compare_val);
+  		add_80_code(0x80032640, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// NFL GameDay 2003, NFL GameDay 2004, and NFL GameDay 2005 (lmao they gave up?)
+   	(((strcmp("SCUS_946.65;1", bootfile)) == 0) || ((strcmp("SCUS_946.90;1", bootfile)) == 0) || ((strcmp("SCUS_946.95;1", bootfile)) == 0)) {
+   		//debug_write("Detected NFL GameDay 2003, 2004, or 2005");
+		/*
+		D0032ACC 001E
+		80032ACC 0000
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x80032ACC, readtoc_compare_val);
+  		add_80_code(0x80032ACC, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// NHL FaceOff 2001 Demo
+   	((strcmp("SCUS_945.78;1", bootfile)) == 0) {
+   		//debug_write("Detected NHL FaceOff 2001 Demo");
+		/*
+		D00F1938 001E
+		800F1938 0000
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x800F1938, readtoc_compare_val);
+  		add_80_code(0x800F1938, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// NHL FaceOff 2001
+   	((strcmp("SCUS_945.77;1", bootfile)) == 0) {
+   		//debug_write("Detected NHL FaceOff 2001");
+		/*
+		D00F2470 001E
+		800F2470 0000
+		my code generated via aprip
+    	*/
+  		add_D0_code(0x800F2470, readtoc_compare_val);
+  		add_80_code(0x800F2470, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Oha-Studio Dance Dance Revolution
+   	((strcmp("SLPM_866.03;1", bootfile)) == 0) {
+   		//debug_write("Detected Oha-Studio Dance Dance Revolution");
+		/*
+		D00FAE58 001E
+		800FAE58 0000
+		code generated via aprip by https://www.psx-place.com/members/trappedinlimbo.156719/
+    	*/
+  		add_D0_code(0x800FAE58, readtoc_compare_val);
+  		add_80_code(0x800FAE58, readtoc_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Ore no Ryouri
+   	((strcmp("SCPS_100.99;1", bootfile)) == 0) {
+   		//debug_write("Detected Ore no Ryouri");
+		/*
+		D0031C1A 1040
+		80031C1A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_m.shtml
+    	*/
+  		add_D0_code(0x80031C1A, common_routine_return_compare_val);
+  		add_80_code(0x80031C1A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Pocket Jiman
+   	((strcmp("SCPS_101.04;1", bootfile)) == 0) { // 3 discs
+   		//debug_write("Detected Pocket Jiman");
+		/*
+		 D0126BDC 001E
+		 80126BDC 0000
+		 code by https://gbatemp.net/members/m4x1mumrez.610331/ generated with APrip
+		*/
+  		add_D0_code(0x80126BDC, readtoc_compare_val);
+  		add_80_code(0x80126BDC, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// PoPoLoCrois Monogatari II
+   	(((strcmp("SCPS_101.12;1", bootfile)) == 0) || ((strcmp("SCPS_101.13;1", bootfile)) == 0) || ((strcmp("SCPS_101.14;1", bootfile)) == 0)) { // 3 discs
+   		//debug_write("Detected PoPoLoCrois Monogatari II");
+		/*
+		 D00B2612 1040
+		 800B2612 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_p.shtml
+		*/
+  		add_D0_code(0x800B2612, common_routine_return_compare_val);
+  		add_80_code(0x800B2612, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Pop'n Music: Animation Melody
+   	((strcmp("SLPM_865.92;1", bootfile)) == 0) {
+   		//debug_write("Pop'n Music: Animation Melody");
+		/*
+		D009E7E8 001E
+		8009E7E8 0000
+		code generated via aprip by https://www.psx-place.com/members/trappedinlimbo.156719/
+    	*/
+  		add_D0_code(0x8009E7E8, readtoc_compare_val);
+  		add_80_code(0x8009E7E8, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Pop'n Music: Disney Tunes
+   	((strcmp("SLPM_866.70;1", bootfile)) == 0) {
+   		//debug_write("Pop'n Music: Disney Tunes");
+		/*
+		D008A45C 001E
+		8008A45C 0000
+		code generated via aprip by https://www.psx-place.com/members/trappedinlimbo.156719/
+    	*/
+  		add_D0_code(0x8008A45C, readtoc_compare_val);
+  		add_80_code(0x8008A45C, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Pop'n Music 2
+   	((strcmp("SLPM_862.94;1", bootfile)) == 0) {
+   		//debug_write("Detected Pop 'N Music 2");
+		/*
+		D0015342 1040
+		80015342 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_p.shtml
+    	*/
+  		add_D0_code(0x80015342, common_routine_return_compare_val);
+  		add_80_code(0x80015342, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Pop'n Music 5
+   	((strcmp("SLPM_869.37;1", bootfile)) == 0) {
+   		//debug_write("Detected Pop'n Music 5");
+	   		/*
+		D0048F34 001E
+		80048F34 0000
+		my code via aprip to patch out readtoc
+		*/
+  		add_D0_code(0x80048F34, readtoc_compare_val);
+  		add_80_code(0x80048F34, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Pop'n Music 6
+   	((strcmp("SLPM_870.89;1", bootfile)) == 0) {
+   		//debug_write("Detected Pop'n Music 6");
+	 		/*
+		D004A24C 001E
+		8004A24C 0000
+		my code via aprip to patch out readtoc
+		*/
+  		add_D0_code(0x8004A24C, readtoc_compare_val);
+  		add_80_code(0x8004A24C, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Resident Evil Survivor
+   	((strcmp("SLPS_025.53;1", bootfile)) == 0) {
+   		//debug_write("Detected Resident Evil Survivor - Japan");
+		/*
+		D0017962 1040
+		80017962 1000
+		'skip mod check' code is from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_b.shtml
+    	*/
+  		add_D0_code(0x80017962, common_routine_return_compare_val);
+  		add_80_code(0x80017962, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+   	((strcmp("SLUS_010.87;1", bootfile)) == 0) {
+   		//debug_write("Detected Resident Evil Survivor - USA");
+		/*
+		D001714E 1040
+		8001714E 1000
+		converted code via aprip
+    	*/
+  		add_D0_code(0x8001714E, common_routine_return_compare_val);
+  		add_80_code(0x8001714E, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+   	(((strcmp("SLES_027.32;1", bootfile)) == 0) || ((strcmp("SLES_027.44;1", bootfile)) == 0)) { // Same code works on both Europe and France versions
+   		//debug_write("Detected Resident Evil Survivor - EUR/FRA");
+		/*
+		D001713E 1040
+		8001713E 1000
+		converted code via aprip
+    	*/
+  		add_D0_code(0x8001713E, common_routine_return_compare_val);
+  		add_80_code(0x8001713E, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Robbit mon Dieu
+   	((strcmp("SCPS_101.03;1", bootfile)) == 0) {
+   		//debug_write("Detected Robbit Mon Dieu");
+		/*
+		D001C646 1040
+		8001C646 1000
+		'skip mod check' code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_r.shtml
+		*/
+  		add_D0_code(0x8001C646, common_routine_return_compare_val);
+  		add_80_code(0x8001C646, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman
+   	((strcmp("SLPS_022.20;1", bootfile)) == 0) {
+   		//debug_write("Detected Rockman 1");
+		/*
+		D006C92A 1040
+		8006C92A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_r.shtml
+		*/
+  		add_D0_code(0x8006C92A, common_routine_return_compare_val);
+  		add_80_code(0x8006C92A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman 2: Dr. Wily no Nazo
+   	((strcmp("SLPS_022.55;1", bootfile)) == 0) {
+   		//debug_write("Detected Rockman 2");
+		/*
+		D006CA82 1040
+		8006CA82 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_r.shtml
+		*/
+  		add_D0_code(0x8006CA82, common_routine_return_compare_val);
+  		add_80_code(0x8006CA82, common_routine_return_patch_val);
+    	install_cheat_engine();
+    } else if
+
+// Rockman 3: Dr. Wily no Saigo!?
+   	((strcmp("SLPS_022.62;1", bootfile)) == 0) {
+   		//debug_write("Detected Rockman 3");
+		/*
+		D006CA1A 1040
+		8006CA1A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_r.shtml
+		*/
+  		add_D0_code(0x8006CA1A, common_routine_return_compare_val);
+  		add_80_code(0x8006CA1A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman 4: Aratanaru Yabou!!
+   	((strcmp("SLPS_023.24;1", bootfile)) == 0) {
+   		//debug_write("Detected Rockman 4");
+	 	/*
+ 		D007009C 001E
+		8007009C 0000
+ 		my code via aprip to patch out readtoc
+		*/
+  		add_D0_code(0x8007009C, readtoc_compare_val);
+  		add_80_code(0x8007009C, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman 5: Blues no Wana!?
+   	((strcmp("SLPS_023.38;1", bootfile)) == 0) {
+   		//debug_write("Detected Rockman 5");
+		/*
+		D006FD84 001E
+		8006FD84 0000
+		my code via aprip
+		*/
+  		add_D0_code(0x8006FD84, readtoc_compare_val);
+  		add_80_code(0x8006FD84, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman X5
+   	((strcmp("SLPM_866.66;1", bootfile)) == 0) {
+   		//debug_write("Detected Rockman X5");
+		/*
+		D0070ED0 001E
+		80070ED0 0000
+		my code via aprip
+		*/
+  		add_D0_code(0x80070ED0, readtoc_compare_val);
+  		add_80_code(0x80070ED0, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman X6
+   	((strcmp("SLPM_869.59;1", bootfile)) == 0) {
+   		//debug_write("Detected Rockman X6");
+		/*
+		D006EC40 001E
+		8006EC40 0000
+		my code via aprip
+		*/
+  		add_D0_code(0x8006EC40, readtoc_compare_val);
+  		add_80_code(0x8006EC40, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Rockman 6
+   	((strcmp("SLPS_023.79;1", bootfile)) == 0) {
+   		//debug_write("Detected Rockman 6");
+		/*
+		D006DA7A 1040
+		8006DA7A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_r.shtml
+		*/
+  		add_D0_code(0x8006DA7A, common_routine_return_compare_val);
+  		add_80_code(0x8006DA7A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Street Fighter EX2 Plus
+   	((strcmp("SLPS_025.08;1", bootfile)) == 0) {
+   		//debug_write("Detected Street Fighter EX2 Plus");
+		/*
+		D01BD48A 1040
+		801BD48A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_s.shtml
+		*/
+  		add_D0_code(0x801BD48A, common_routine_return_compare_val);
+  		add_80_code(0x801BD48A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	((strcmp("SLPM_805.17;1", bootfile)) == 0) {
+   		//debug_write("Detected Street Fighter EX2 Plus Demo");
+		/*
+		D01BD13E 1040
+		801BD13E 1000
+		my code via aprip gameshark code conversion
+		*/
+  		add_D0_code(0x801BD48A, common_routine_return_compare_val);
+  		add_80_code(0x801BD13E, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Strider 2
+   	((strcmp("SLUS_011.63;1", bootfile)) == 0) {
+   		//debug_write("Detected Strider 2 - USA");
+		/*
+		D01F6570 001E
+		801F6570 0000
+		my code via aprip
+		*/
+  		add_D0_code(0x801F6570, readtoc_compare_val);
+  		add_80_code(0x801F6570, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Tomba! 2: The Evil Swine Return
+   	((strcmp("SCUS_944.54;1", bootfile)) == 0) {
+   		//debug_write("Detected TOMBA! 2 - USA");
+		/*
+		D002542C 001E
+		8002542C 0000
+		my code via aprip
+		*/
+  		add_D0_code(0x8002542C, readtoc_compare_val);
+  		add_80_code(0x8002542C, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Tron ni Kobun
+   	((strcmp("SLPS_021.08;1", bootfile)) == 0) {
+   		//debug_write("Detected Tron ni Kobun ");
+		/*
+		D004E168 001E
+		8004E168 0000
+		my code via aprip
+		*/
+  		add_D0_code(0xD004E168, readtoc_compare_val);
+  		add_80_code(0x8004E168, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Vandal Harts II
+   	((strcmp("SLUS_009.40;1", bootfile)) == 0) {
+   		//debug_write("Detected Vandal Harts II - USA");
+	 		/*
+		D00865FC 001E
+		800865FC 0000
+		my code via aprip to patch out readtoc
+		*/
+  		add_D0_code(0x800865FC, readtoc_compare_val);
+  		add_80_code(0x800865FC, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Wild Arms 2
+   	(((strcmp("SCUS_944.84;1", bootfile)) == 0) || ((strcmp("SCUS_944.98;1", bootfile)) == 0)) { // 2 discs
+   		//debug_write("Detected Wild Arms 2 - USA");
+	   		/*
+   		D003A4E8 001E
+   		8003A4E8 0000
+ 		my code via aprip to patch out readtoc
+    	*/
+  		add_D0_code(0x8003A4E8, readtoc_compare_val);
+  		add_80_code(0x8003A4E8, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+   	((strcmp("SCUS_945.92;1", bootfile)) == 0) {
+   		//debug_write("Detected Wild Arms 2 - USA Demo");
+		/*
+   		D003A5D4 001E
+   		8003A5D4 0000
+		my code via aprip gameshark code conversion on my own code (code-ception)
+    	*/
+  		add_D0_code(0x8003A5D4, readtoc_compare_val);
+  		add_80_code(0x8003A5D4, readtoc_patch_val);
+		install_cheat_engine();
+    } else if
+
+// World Soccer Jikkyou Winning Eleven 4
+   	((strcmp("SLPM_862.91;1", bootfile)) == 0) { // 2 revisions, same code works on rev 0 and rev 1
+   		//debug_write("Detected Winning Eleven 4");
+		/*
+   		D01030CA 1040
+		801030CA 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_w.shtml
+    	*/
+  		add_D0_code(0x801030CA, common_routine_return_compare_val);
+  		add_80_code(0x801030CA, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// XI[SAI] Jumbo
+   	((strcmp("SCPS_101.23;1", bootfile)) == 0) {
+   		//debug_write("Detected XI[Sai] Jumbo");
+	   	/*
+   		D010178A 1040
+		8010178A 1000
+		code 1 of 3 from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_x.shtml
+    	*/
+  		add_D0_code(0x8010178A, common_routine_return_compare_val);
+  		add_80_code(0x8010178A, common_routine_return_patch_val);
+ 		/*
+		D00A370A 1040
+		800A370A 1000
+		code 2 of 3 from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_x.shtml
+    	*/
+  		add_D0_code(0x800A370A, common_routine_return_compare_val);
+  		add_80_code(0x800A370A, common_routine_return_patch_val);
+ 		/*
+		D0113C1A 1040
+		80113C1A 1000
+		code 3 of 3 from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_x.shtml
+    	*/
+  		add_D0_code(0x80113C1A, common_routine_return_compare_val);
+  		add_80_code(0x80113C1A, common_routine_return_patch_val);
+		install_cheat_engine();
+    } else if
+
+// Yu-Gi-Oh! Forbidden Memories
+   	(((strcmp("SLPM_863.96;1", bootfile)) == 0) || ((strcmp("SLPM_863.98;1", bootfile)) == 0) || ((strcmp("SLUS_014.11;1", bootfile)) == 0) || ((strcmp("SLES_039.47;1", bootfile)) == 0) || ((strcmp("SLES_039.48;1", bootfile)) == 0) || ((strcmp("SLES_039.49;1", bootfile)) == 0) || ((strcmp("SLES_039.50;1", bootfile)) == 0) || ((strcmp("SLES_039.51;1", bootfile)) == 0)) { //same code skips mod check on ALL VERSIONS EVER!
+   		//debug_write("Detected Yu-Gi-Oh! Forbidden Memories");
+		/*
+		D016818A 1040
+		8016818A 1000
+		code from consolecopyworld: https://consolecopyworld.com/psx/psx_game_codes_y.shtml
+    	*/
+  		add_D0_code(0x8016818A, common_routine_return_compare_val);
+  		add_80_code(0x8016818A, common_routine_return_patch_val);
+		install_cheat_engine();
+    }
+}
\ No newline at end of file
diff --git a/loader/ap-bypass.h b/loader/ap-bypass.h
new file mode 100644
index 0000000..ddff419
--- /dev/null
+++ b/loader/ap-bypass.h
@@ -0,0 +1,16 @@
+
+#pragma once
+
+void activate_anti_anti_piracy(const char * bootfile, const int32_t load_addr);
+
+void add_30_code(const uint32_t gs1, const uint8_t gs2);
+void add_E0_code(const uint32_t gs1, const uint8_t gs2);
+void add_E1_code(const uint32_t gs1, const uint8_t gs2);
+
+void add_80_code(const uint32_t gs1, const uint16_t gs2);
+void add_D0_code(const uint32_t gs1, const uint16_t gs2);
+void add_D1_code(const uint32_t gs1, const uint16_t gs2);
+
+void install_cheat_engine();
+
+extern bool cheat_engine_installed;
diff --git a/tmp/og-tonyhax.Icq/loader/bios-asm.S b/loader/bios-asm.S
index 93837fa..a71573d 100644
--- a/tmp/og-tonyhax.Icq/loader/bios-asm.S
+++ b/loader/bios-asm.S
@@ -69,11 +69,6 @@ memcpy:
 	li t1, 0x2A
 	j 0xA0
 
-.global std_out_puts
-std_out_puts:
-	li t1, 0x3E
-	j 0xA0
-
 .global DoExecute
 DoExecute:
 	# Pepsiman (J) crashes if s5 is not zero
@@ -137,6 +132,11 @@ CdReadSector:
 	li t1, 0xA5
 	j 0xA0
 
+.global SetMemSize
+SetMemSize:
+	li t1, 0x9F
+	j 0xA0
+
 ###############
 # B-FUNCTIONS #
 ###############
diff --git a/tmp/og-tonyhax.Icq/loader/bios.c b/loader/bios.c
index 0f3d558..2ec6a3f 100644
--- a/tmp/og-tonyhax.Icq/loader/bios.c
+++ b/loader/bios.c
@@ -5,23 +5,13 @@
 #include "debugscreen.h"
 #include "str.h"
 
-void * original_disc_error;
-
-bool console_has_tty() {
-	/*
-	 * Check if the console has a SCN2681 TTY used for debug by writing data to the control
-	 * registers and reading it back.
-	 *
-	 * The control is 16 bit wide, and is accessed by writing or reading twice the same register.
-	 */
-	volatile uint8_t * scn2681modereg = (uint8_t *) 0x1F802020;
+// Set to zero unless you are using an emulator or have a physical UART on the PS1, else it'll freeze
+const uint32_t tty_enabled = 0;
 
-	*scn2681modereg = 0x55;
-	*scn2681modereg = 0xAA;
-	return *scn2681modereg == 0x55 && *scn2681modereg == 0xAA;
-}
+void * original_disc_error;
 
 void bios_reinitialize() {
+	// See https://github.com/ogamespec/psxdev/blob/master/reverse/Main.c for reference to some of this...
 	// Disable interrupts
 	EnterCriticalSection();
 
@@ -52,8 +42,11 @@ void bios_reinitialize() {
 	I_STAT = 0;
 	I_MASK = 0;
 
-	// Setup devices.
-	InstallDevices(console_has_tty());
+	// Setup devices
+	InstallDevices(tty_enabled);
+
+	// BIOS sets the memory to 8MB (somewhere, haven't seen exactly where but this is well known), which causes the RAM to be mirrored 4 times since there is actually only 2MBs of RAM. The thing is, some games set this to the 'correct' value of 2 for the appropriate 2MBs of RAM. This will cause issues when booting games, so we explicitly set it like the BIOS does which is what every game initially expects at boot.
+	SetMemSize(8); // fixes Ridge Racer USA GSHAX boot method getting stuck at the doexecute() call for discs such as the Tonyhax International ROM Flasher CD
 
 	/*
 	 * Configure with default values
@@ -92,7 +85,7 @@ void bios_reinitialize() {
 	// End of code adapted
 
 	// Re-enable interrupts
-	ExitCriticalSection();
+	ExitCriticalSection(); // unnecesary because SetConf() does this? Waiting on verdict from Socram8888: https://github.com/socram8888/tonyhax/issues/149
 
 	// Save for later
 	original_disc_error = BIOS_A0_TABLE[0xA1];
diff --git a/tmp/og-tonyhax.Icq/loader/bios.h b/loader/bios.h
index c5b26f3..9498989 100644
--- a/tmp/og-tonyhax.Icq/loader/bios.h
+++ b/loader/bios.h
@@ -219,13 +219,6 @@ void ExitCriticalSection();
  */
 uint32_t todigit(char c);
 
-/**
- * Prints a text through the TTY.
- *
- * @param text text to print
- */
-void std_out_puts(const char * text);
-
 /**
  * Starts a previously loaded executable.
  *
@@ -439,3 +432,10 @@ void InstallDevices(uint32_t enable_tty);
  * Table C, call 0x1C.
  */
 void AdjustA0Table(void);
+
+/**
+ * Called to set the RAM to 8MBs, which enables the mirroring of RAM 4 times in the real 2MBs of RAM (which is exactly what the BIOS ends up doing)
+ *
+ * Table A, call 0x9F.
+ */
+void SetMemSize(uint8_t mem_size);
\ No newline at end of file
diff --git a/tmp/og-tonyhax.Icq/loader/cdrom.c b/loader/cdrom.c
index dddc533..40d9b6f 100644
--- a/tmp/og-tonyhax.Icq/loader/cdrom.c
+++ b/loader/cdrom.c
@@ -43,6 +43,40 @@ void cd_command(uint_fast8_t cmd, const uint8_t * params, uint_fast8_t params_le
 	CD_REGS[1] = cmd;
 }
 
+void cd_command_race(uint_fast8_t cmd, const uint8_t * params, uint_fast8_t params_len) {
+
+	// Wait for previous command to finish, if any
+	//while (CD_REGS[0] & 0x80);
+
+	// Switch to page 0
+	cd_set_page(0);
+
+	// Clear read and write FIFOs
+	CD_REGS[3] = 0xC0;
+
+	// Copy request
+	while (params_len != 0) {
+		CD_REGS[2] = *params;
+		params++;
+		params_len--;
+	}
+
+	// Switch to page 1
+	cd_set_page(1);
+
+	// Disable interrupts as we'll poll
+	CD_REGS[2] = 0x00;
+
+	// Acknowledge interrupts, if there were any
+	CD_REGS[3] = 0x07;
+
+	// Switch to page 0
+	cd_set_page(0);
+
+	// Finally write command to start
+	CD_REGS[1] = cmd;
+}
+
 uint_fast8_t cd_wait_int(void) {
 
 	// Wait for command to finish, if any
@@ -64,6 +98,28 @@ uint_fast8_t cd_wait_int(void) {
 	return interrupt;
 }
 
+uint_fast8_t cd_wait_int_race(void) {
+
+	// Wait for command to finish, if any
+	//while (CD_REGS[0] & 0x80);
+
+	// Switch to page 1
+	cd_set_page(1);
+
+	// Wait until an interrupt happens (int != 0)
+	uint_fast8_t interrupt;
+	do {
+		interrupt = CD_REGS[3] & 0x07;
+	} while (interrupt == 0);
+
+	// Acknowledge it
+	CD_REGS[3] = 0x07;
+
+	// Return it
+	return interrupt;
+}
+
+
 uint_fast8_t cd_read_reply(uint8_t * reply_buffer) {
 
 	// Switch to page 1
@@ -81,6 +137,9 @@ uint_fast8_t cd_read_reply(uint8_t * reply_buffer) {
 	return len;
 }
 
+//we can't trust this due to a race condition. If the actual BIOS executes a CD command (affects the Tonyhax International ROM), or a game is in the middle of executing a CD command when Tonyhax International starts (affects GSHAX), and this is executed close enough in the Tonyhax International loader code itself, it will get stuck if done like below:
+
+/*
 bool cd_drive_init() {
 	cd_command(CD_CMD_INIT, NULL, 0);
 
@@ -96,18 +155,22 @@ bool cd_drive_init() {
 
 	return true;
 }
+*/
 
-bool cd_drive_reset() {
-	// Issue a reset
+void cd_drive_init() {
+	cd_command_race(CD_CMD_INIT, NULL, 0);
+
+	cd_wait_int_race();
+	cd_wait_int_race();
+}
+
+void cd_drive_reset() {
+	// Issue a reset (looses authentication and or unlock when completed, so do an unlock after this)
 	cd_command(CD_CMD_RESET, NULL, 0);
 
-	// Should succeed with 3
-	if (cd_wait_int() != 3) {
-		return false;
-	}
+	// Should succeed with 3 but doesn't sometimes so we can't check the return value
+	cd_wait_int();
 
 	// Need to wait for some cycles before it springs back to life
-	for (int i = 0; i < 0x400000; i++);
-
-	return true;
+	for (volatile int i = 0; i < 0x400000; i++); // unmodifiable compiler code when using -Os optimizations
 }
diff --git a/tmp/og-tonyhax.Icq/loader/cdrom.h b/loader/cdrom.h
index 438e7cd..c26874d 100644
--- a/tmp/og-tonyhax.Icq/loader/cdrom.h
+++ b/loader/cdrom.h
@@ -8,6 +8,12 @@
 #define CD_CMD_TEST 0x19
 #define CD_CMD_RESET 0x1C
 #define CD_TEST_REGION 0x22
+#define CD_CMD_SET_SESSION 0x12
+#define CD_CMD_STOP 0x08
+#define CD_CMD_GETID 0x1A
+#define CD_CMD_SETMODE 0x0E
+#define CD_CMD_GETTN 0x13
+#define CD_CMD_GETTD 0x14
 
 /**
  * Starts executing a CD command.
@@ -38,11 +44,9 @@ uint_fast8_t cd_read_reply(uint8_t * reply_buffer);
  *
  * @returns true if succeded, or false otherwise.
  */
-bool cd_drive_init(void);
+//bool cd_drive_init(void);
+// we can't trust that:
+void cd_drive_init();
 
-/**
- * Resets the drive.
- *
- * @returns true if succeded, or false otherwise.
- */
-bool cd_drive_reset(void);
+// Resets the drive.
+void cd_drive_reset();
diff --git a/tmp/og-tonyhax.Icq/loader/debugscreen.c b/loader/debugscreen.c
index cb8c32e..926cb0c 100644
--- a/tmp/og-tonyhax.Icq/loader/debugscreen.c
+++ b/loader/debugscreen.c
@@ -113,7 +113,7 @@ void debug_init() {
 	gpu_flush_cache();
 
 	// Draw border
-	debug_text_at(TH_MARGIN, 40, "tonyhax " STRINGIFY(TONYHAX_VERSION));
+	debug_text_at(TH_MARGIN, 40, "tonyhax international " STRINGIFY(TONYHAX_VERSION));
 	struct gpu_solid_rect band = {
 		.pos = {
 			.x = 0,
@@ -237,9 +237,12 @@ void debug_write(const char * str, ...) {
 	} else {
 		last_printed_count++;
 
-		// Same line, so print with a repeat counter
-		mini_sprintf(formatted_repeated, "%s (x%d)", last_printed_line, last_printed_count);
-
+		// Same line, so print with a repeat counter unless we are waiting for controller input on a Japanese console
+		if(!controller_input) {
+			mini_sprintf(formatted_repeated, "%s (x%d)", last_printed_line, last_printed_count);
+		} else {
+			mini_sprintf(formatted_repeated, "%s", last_printed_line);
+		}
 		to_print = formatted_repeated;
 	}
 
diff --git a/tmp/og-tonyhax.Icq/loader/debugscreen.h b/loader/debugscreen.h
index 6ae71a5..d06a360 100644
--- a/tmp/og-tonyhax.Icq/loader/debugscreen.h
+++ b/loader/debugscreen.h
@@ -10,3 +10,5 @@ void debug_write(const char * str, ...);
 void debug_text_at(uint_fast16_t x, uint_fast16_t y, const char * str);
 
 void debug_switch_standard(bool pal);
+
+extern bool controller_input;
\ No newline at end of file
diff --git a/tmp/og-tonyhax.Icq/loader/generate-tonyhax-mcs.sh b/loader/generate-tonyhax-mcs.sh
index 33116fa..b01a8b9 100644
--- a/tmp/og-tonyhax.Icq/loader/generate-tonyhax-mcs.sh
+++ b/loader/generate-tonyhax-mcs.sh
@@ -25,11 +25,11 @@ load_len=$(printf "%08X" $(stat -c %s $bin_file))
 
 # Create file
 cp "$tpl_file" "$mcs_file"
-echo -n "tonyhax ${version}" | dd status=none conv=notrunc bs=1 seek=132 of="$mcs_file"
+echo -n "tonyhax-i ${version}" | dd status=none conv=notrunc bs=1 seek=132 of="$mcs_file"
 dd status=none conv=notrunc bs=1 seek=384 if=$bin_file of="$mcs_file"
 
 # Insert address at 0xC0 and length at 0xC4, which is 0x40 and 0x44 inside the save file header
-echo -ne "\x${ro_start:6:2}\x${ro_start:4:2}\x${ro_start:2:2}\x${ro_start:0:2}\x${load_len:6:2}\x${load_len:4:2}\x${load_len:2:2}\x${load_len:0:2}" | dd status=none conv=notrunc of=tonyhax.mcs bs=1 seek=192
+echo -ne "\x${ro_start:6:2}\x${ro_start:4:2}\x${ro_start:2:2}\x${ro_start:0:2}\x${load_len:6:2}\x${load_len:4:2}\x${load_len:2:2}\x${load_len:0:2}" | dd status=none conv=notrunc of="$mcs_file" bs=1 seek=192
 
 # Cleanup
 rm $bin_file
diff --git a/tmp/og-tonyhax.Icq/loader/patch-ap.S b/tmp/og-tonyhax.Icq/loader/patch-ap.S
deleted file mode 100644
index 85511eb..0000000
--- a/tmp/og-tonyhax.Icq/loader/patch-ap.S
+++ /dev/null
@@ -1,196 +0,0 @@
-
-#include <regdef.h>
-
-.text
-
-#
-# Intercepts the syscall(1) (aka EnterCriticalSection).
-#
-# When this code is executed, the registers are as follows:
-#   - v0: saved thread registers, must NOT be modified.
-# The rest of the registers are not critical and can be used freely.
-#
-.globl patch_ap_start
-patch_ap_start:
-	# Load the SP value
-	lw t0, 0x7C(v0)
-
-	#
-	# If we are being called from an antimodchip module, the call stack will look like this:
-	#  - (game code)
-	#  - ap_check
-	#  - ap_failed
-	#  - StopCallback
-	#  - disable_ints
-	#  - EnterCriticalSection
-	#
-	# For all known modules, the return address from StopCallback to ap_failed sits at SP+0x28.
-	#
-	# Before reading from this address, we will check that after adding that offset, we do not
-	# cross a 2MB boundary, which could cause an illegal memory read.
-	#
-	# Without this check the following games crash:
-	#  - Elemental Gearbolt (U) (SLUS-00654), calling with a stack at 0x807FFFE0, as we attempt
-	#    to read from 0x80800008.
-	#  - Rival Schools (U) (SLUS-00681), calling with a stack of 0x801FFFD8, as we attempt to
-	#    read from 0x80200000. A mirror would be generally present here, but not for this game
-	#    as it calls SetMemSize(2) to intentionally block this.
-	#
-	# Some games, like Grind Session (U) (SCUS-94568) use the scratchpad during gameplay for the
-	# stack, which is only 1KB. For now, we will not add a safety check for this case since the
-	# vast majority of games store the stack in RAM and no game is known to crash without it.
-	#
-	addi t1, t0, 0x28
-	xor t1, t0
-	srl t1, 21
-	bne t1, zero, patch_ap_skip
-
-	# Load alledged return address
-	lw t1, 0x28(t0)
-
-	#
-	# Check now if the loaded value could be a word-aligned address in either the KUSEG
-	# (0x00000000-0x007FFFFF) or the KSEG0 (0x80000000-0x807FFFFF) regions, which is were user
-	# code is executed.
-	#
-	# Most games use the KSEG0, except for Emperors New Groove (U) (SCUS-94571) whose programmers
-	# seemed to prefer the KUSEG region.
-	#
-	# We cannot limit ourselves to checking the first 2MB of RAM, because some games, like
-	# Robbit Mon Dieu (J) (SCPS-10103) use a mirror (0x80600000-0x807FFFFF).
-	#
-	li t2, 0x7F800003
-	and t2, t1
-	bne t2, zero, patch_ap_skip
-
-	#
-	# First, we will attempt to handle a version 1 antimodchip module.
-	#
-	# This checks only for the presence of a dumb modchip, by checking if the SCEx counter
-	# increments when it should not. It is also only capable of displaying the stop screen
-	# in Japanese.
-	#
-	# The offsets for some of the checked games are:
-	#
-	# Um Jammer Lammy (PAL-E):
-	#  - ap_check           (0x801D8008)
-	#  - ap_failed          (0x801D83E0, called from 0x801D8174)
-	#  - StopCallback       (0x800356C4, called from 0x801D8400)
-	#  - disable_ints       (0x80035B54, called from 0x800356E0)
-	#  - EnterCriticalSection
-	#
-	# For Saru! Get You (NTSC-J):
-	#  - ap_check           (0x80136950)
-	#  - ap_failed          (0x80136D28, called from 0x80136ABC)
-	#  - StopCallback       (0x8002E814, called from 0x80136D48)
-	#  - disable_ints       (0x8002ECA4, called from 0x8002E82C)
-	#  - EnterCriticalSection
-	#
-	# The return call from StopCallback to ap_failed is located at SP+0x28. We will check if
-	# at this address +0x74 exists a "li v0, 0xE6000002", which is a black rentangle passed to
-	# the DrawPrim function to clear the screen.
-	#
-	# If it exists, we will patch the thread state to return back to ap_check, as if the
-	# ap_failed function had returned.
-	#
-
-	# Compare signature, and test for v2 if does not match
-	lw t2, 0x74(t1)
-	li t3, 0x3C02E600
-	bne t2, t3, patch_ap_v15
-
-	lw t2, 0x78(t1)
-	li t3, 0x34420002
-	bne t2, t3, patch_ap_v15
-
-	# Load return address from ap_failed to ap_check
-	lw t1, 0xE8(t0)
-
-	# Adjust stack pointer
-	addi t0, 0xF0
-
-	# Save and return
-	b patch_ap_save
-
-	#
-	# Handle another variant of the v1, used by Vandal Hearts II - Tenjou no Mon (J) (SLPM-86251)
-	#  - ap_check           (0x800C4868)
-	#  - ap_failed          (0x800C4C40, called from 0x800C49D4)
-	#  - StopCallback       (0x800D2700, called from 0x800C4C58)
-	#  - disable_ints       (0x800D2B90, called from 0x800D2718)
-	#  - EnterCriticalSection
-	#
-	# Same idea, except the load is now a "li v1, 0xE6000002" at +0x64 bytes after ap_failed
-	# returns to ap_check.
-	#
-	# The offsets are the same as for v2, so we will reuse those adjusts.
-	#
-patch_ap_v15:
-	lw t2, 0x64(t1)
-	li t3, 0x3C03E600
-	bne t2, t3, patch_ap_v2
-
-	lw t2, 0x68(t1)
-	li t3, 0x34630002
-	beq t2, t3, patch_ap_adjust_v2
-
-	#
-	# We will now attempt to patch an antimodchip v2 module.
-	#
-	# This one is smarter and checks that the SCEx wobble is present in the inner tracks,
-	# to detect CD swapping; and for dumb modchips by checking for absence of the wobble
-	# in the outer tracks.
-	#
-	# The offsets for some of the checked games are:
-	#
-	# Rockman 2 - Dr. Wily no Nazo (J) (SLPS-02255):
-	#  - ap_check           (0x8006CA58)
-	#  - ap_failed          (0x8006D654, called from 0x8006CE5C and 0x8006D238)
-	#  - StopCallback       (0x80024524, called from 0x8006D66C)
-	#  - disable_ints       (0x800249B4, called from 0x8002453C)
-	#  - EnterCriticalSection
-	#
-	# The return address from StopCallback to ap_failed is located at SP+0x28, exactly as above
-	# so we will not load it again.
-	#
-	# For this other version, we will check if at this return address +0x10 bytes exists a
-	# "sh zero, 0x1F801DAA", which is used to mute the audio.
-	#
-	# If that exists, we will patch the thread state to return back to ap_check.
-	#
-patch_ap_v2:
-	# Compare signature
-	lw t2, 0x18(t1)
-	li t3, 0x3C011F80
-	bne t2, t3, patch_ap_skip
-
-	lw t2, 0x1C(t1)
-	li t3, 0xA4201DAA
-	bne t2, t3, patch_ap_skip
-
-patch_ap_adjust_v2:
-	# Load return address to from ap_failed to ap_check
-	lw t1, 0x120(t0)
-
-	# Adjust stack pointer
-	addi t0, 0x128
-
-patch_ap_save:
-	# Zero the s0 and s1 stored in the thread state, so the state machine used by ap_check exits
-	sw zero, 0x48(v0)
-	sw zero, 0x4C(v0)
-
-	# Save adjusted stack pointer and return address
-	sw t0, 0x7C(v0)
-	sw t1, 0x88(v0)
-
-.globl patch_ap_success
-patch_ap_success:
-	j 0x12341234
-
-.globl patch_ap_skip
-patch_ap_skip:
-	j 0x12341234
-
-.globl patch_ap_end
-patch_ap_end:
diff --git a/tmp/og-tonyhax.Icq/loader/patch-fpb.S b/tmp/og-tonyhax.Icq/loader/patch-fpb.S
deleted file mode 100644
index e26fb72..0000000
--- a/tmp/og-tonyhax.Icq/loader/patch-fpb.S
+++ /dev/null
@@ -1,35 +0,0 @@
-
-#include <regdef.h>
-
-.text
-
-#
-# The anti-FreePSXBoot patch.
-#
-# This patch is called right at the very end of the last step in the read sector finite state
-# machine:
-# https://github.com/grumpycoders/pcsx-redux/blob/f6484e8010a40a81e4019d9bfa1a9d408637b614/src/mips/openbios/sio0/card.c#L194
-#
-# When this code is executed, the registers are as follows:
-#   - v0 contains 1, or "success".
-#   - a1 contains the read buffer
-#   - a2 contains the current sector number
-#
-# If the sector being read is sector 0 and it contains "FPBZ" at +0x7C, we modify the read data
-# so it is detected as corrupted and the game skips reading from it
-#
-# The offsets have been checked against BIOSes 2.2, 3.0, 4.1 and 4.4
-#
-.globl patch_fpb_start
-patch_fpb_start:
-	lw t0, 0x7C(a1)
-	li t1, 0x5A425046
-	bne a2, 0, patch_fpb_ret
-	bne t0, t1, patch_fpb_ret
-
-	sw zero, 0(a1)
-patch_fpb_ret:
-	j 0x5B54
-
-.globl patch_fpb_end
-patch_fpb_end:
diff --git a/tmp/og-tonyhax.Icq/loader/patch-uart.S b/tmp/og-tonyhax.Icq/loader/patch-uart.S
deleted file mode 100644
index da95257..0000000
--- a/tmp/og-tonyhax.Icq/loader/patch-uart.S
+++ /dev/null
@@ -1,121 +0,0 @@
-
-#include <regdef.h>
-
-.text
-
-#
-# This is a complete replacement for the original std_out_putc the BIOS has.
-#
-# In this function:
-#  - a0: data to bitbang
-#  - t0: working registers
-#  - t1: bits to send
-#  - t2: last IRQ flag value
-#  - t3: 0x1F800000 (I/O start address)
-#  - t4: COP0 SR value
-#
-.globl patch_uartputc_start
-patch_uartputc_start:
-	# Add start (0) and stop (1) bits to byte
-	andi a0, 0xFF
-	sll a0, 1
-	ori a0, 0x200
-
-	# Newline (after processing)
-	li t0, (0x0A << 1 | 0x200)
-
-	# Bits to send (1 start + 8 data + 1 stop)
-	li t1, 10
-
-	# Compare against newline (0x0A)
-	bne a0, t0, notnl
-
-	# If newline, prepend a 0x0D, like the original function did and increment bit count
-	sll a0, 10
-	ori a0, (0x0D << 1 | 0x200)
-	addi t1, 10
-
-notnl:
-	# We will directly manipulate the COP0 status registers instead of using EnterCriticalSection
-	# to avoid other threads/interrupts from fucking up the timing.
-	#
-	# The reason is two-fold:
-	#  - The kernel does not support reentrant calls - if something calls us while we are
-	#    executing kernel code and we generate a syscall, we'd nuke the current thread state.
-	#
-	#  - SetConf calls printf while re-configuring the TCBs (thread control blocks). Executing
-	#    *any* interrupt at that point (which includes syscalls) will cause the interrupt
-	#    handler to write the current thread state to the zero address, wiping the interrupt
-	#    trampoline at 0x80.
-	#
-	# By directly manipulating this register we're opening ourselves to all kinds of race
-	# conditions, but since this is just for debugging tonyhax, that's good enough for me.
-
-	# Load current SR state in t4
-	mfc0 t4, $12
-
-	# Clear bits 10 and 0, the same flags WarmBoot clears
-	li t0, 0xFFFFFBFE
-	and t0, t4
-	mtc0 t0, $12
-
-	# Load I/O start
-	lui t3, 0x1F80
-
-	# Set timer 0 target to 293 cycles (33868800Hz/115200bps-1)
-	li t0, 293
-	sw t0, 0x1108(t3)
-
-	# Start timer 0 in:
-	# - Source clock to SysClk (33868800Hz)
-	# - Free-running mode
-	# - Reset on reaching target value
-	# - IRQ on repeat mode (can be fired multiple times)
-	# - Toggle IRQ flag (bit 10) on every IRQ
-	#
-	# We must not use the "reached target value" flag because that seems to be affected by some
-	# kind of undocumented hardware errata. In real hardware, that flag can read zero if the
-	# elapsed cycles between timer start and read and target values are both even or odd.
-	#
-	# Also note that although we are using the IRQ bits, interrupts are actually disabled so
-	# we will busy poll the corresponding bits.
-	li t0, 0x04D8
-	sw t0, 0x1104(t3)
-
-	# Current timer IRQ flag status
-	li t2, 0x0400
-
-writebit:
-	# Emit bit via /JOY pin of port 2.
-	# We need to invert it, then put it into JOY_CTRL.13.
-	# The XOR also sets the bit JOY_CTRL.2 which enables outputing the /JOY signal
-	andi t0, a0, 1
-	sll t0, 13
-	xori t0, 0x2002
-	sh t0, 0x104A(t3)
-
-	# Shift right current buffer
-	srl a0, 1
-
-	# Decrement count while we're waiting
-	addi t1, -1
-
-	# Wait until the interrupt flag toggles
-writewait:
-	lw t0, 0x1104(t3)
-	andi t0, 0x0400
-	beq t0, t2, writewait
-
-	# Save current IRQ flag status
-	move t2, t0
-
-	# If not done, keep going
-	bne t1, zero, writebit
-
-	# Restore coprocessor flags
-	mtc0 t4, $12
-
-	jr ra
-
-.global patch_uartputc_end
-patch_uartputc_end:
diff --git a/tmp/og-tonyhax.Icq/loader/patch-vandal-hearths-2.S b/tmp/og-tonyhax.Icq/loader/patch-vandal-hearths-2.S
deleted file mode 100644
index 67f389a..0000000
--- a/tmp/og-tonyhax.Icq/loader/patch-vandal-hearths-2.S
+++ /dev/null
@@ -1,35 +0,0 @@
-
-#include <regdef.h>
-
-.text
-
-#
-# This game needs a special treatment, as it has the regular antipiracy, but also an extra check
-# by calling CdGetDiskType. If it detects the disc is a burned one, it aborts.
-#
-# Furthermore, if the BIOS is an European one, it gets stuck on a loop, calling the AP module
-# forever.
-#
-# So we will just nuke the antipiracy call. This function is supposed to return a nonzero, but
-# we do not need to patch v0 as there is a load constant into v0 right before the call.
-#
-.globl patch_vandal_start
-patch_vandal_start:
-	# Load address where the call to antipiracy sits
-	la t0, 0x80040C98
-
-	# Check if it matches "jal 0x80042854"
-	lw t1, 0(t0)
-	li t2, 0x0C010A15
-	bne t1, t2, patch_vandal_return
-
-	# If it does, NOP the opcode
-	sw zero, 0(t0)
-
-.globl patch_vandal_return
-patch_vandal_return:
-	# This will be replaced with the real address
-	j 0x12341234
-
-.globl patch_vandal_end
-patch_vandal_end:
diff --git a/tmp/og-tonyhax.Icq/loader/patcher.c b/tmp/og-tonyhax.Icq/loader/patcher.c
deleted file mode 100644
index 27c1c49..0000000
--- a/tmp/og-tonyhax.Icq/loader/patcher.c
+++ /dev/null
@@ -1,147 +0,0 @@
-
-#include "bios.h"
-#include "debugscreen.h"
-#include "str.h"
-#include "patcher.h"
-
-inline void encode_j(void * jump_location, const void * jump_dest) {
-	uint32_t * words = (uint32_t *) jump_location;
-	words[0] = 0x08000000 | (((uint32_t) jump_dest >> 2) & 0x3FFFFFF);
-}
-
-inline void encode_jal(void * jump_location, const void * jump_dest) {
-	uint32_t * words = (uint32_t *) jump_location;
-	words[0] = 0x0C000000 | (((uint32_t) jump_dest >> 2) & 0x3FFFFFF);
-}
-
-inline void encode_li(void * load_location, int regnum, uint32_t value) {
-	uint32_t * words = (uint32_t *) load_location;
-
-	// LUI - Load Upper Immediate
-	words[0] = 0x3C000000 | (regnum << 16) | (value >> 16);
-
-	// ORI - OR Immediate
-	words[1] = 0x34000000 | (regnum << 21) | (regnum << 16) | (value & 0xFFFF);
-}
-
-uint8_t * install_generic_antipiracy_patch(uint8_t * install_addr) {
-	// Exports defined by the patch
-	extern uint8_t patch_ap_start;
-	extern uint8_t patch_ap_end;
-	extern uint8_t patch_ap_skip;
-	extern uint8_t patch_ap_success;
-
-	debug_write(" * Generic antipiracy");
-
-	// Get the handler info structure
-	handler_info_t * syscall_handler = bios_get_syscall_handler();
-
-	// Get the start of the verifier function (the only one set)
-	uint32_t * verifier = (uint32_t *) syscall_handler->verifier;
-
-	/*
-	 * At opcode 20 it accesses an 4-word array which contain where to jump depending on the
-	 * syscall performed. We're interested in modifying the value for 1 (EnterCriticalSection)
-	 * so we can intercept it and defuse the antimodchip.
-	 */
-	uint32_t lw_op = verifier[20];
-	if ((lw_op >> 16) != 0x8C39) {
-		debug_write("Aborted! Please report this!");
-		return install_addr;
-	}
-
-	// Extract location of cases array
-	void ** cases_array = (void **) (lw_op & 0xFFFF);
-
-	// Copy blob
-	memcpy(install_addr, &patch_ap_start, &patch_ap_end - &patch_ap_start);
-
-	/*
-	 * Insert the jump to the original code, which we'll use if the call was not originated from
-	 * an antipiracy module.
-	 */
-	encode_j(install_addr + (&patch_ap_skip - &patch_ap_start), cases_array[1]);
-
-	/*
-	 * Insert the jump we'll use to exit the exception handler once we have finished patching up
-	 * the thread state if the call was indeed originated from an antipiracy module.
-	 *
-	 * We'll use the address of syscall(0) which behaves as a nop to exit the exception.
-	 */
-	encode_j(install_addr + (&patch_ap_success - &patch_ap_start), cases_array[0]);
-
-	// Finally replace
-	cases_array[1] = install_addr;
-
-	return install_addr + (&patch_ap_end - &patch_ap_start);
-}
-
-uint8_t * install_vandal_patch(uint8_t * install_addr) {
-	// Exports defined by the patch
-	extern uint8_t patch_vandal_start;
-	extern uint8_t patch_vandal_return;
-	extern uint8_t patch_vandal_end;
-
-	debug_write(" * Vandal Hearths 2 AP");
-
-	// Copy blob
-	memcpy(install_addr, &patch_vandal_start, &patch_vandal_end - &patch_vandal_start);
-
-	// Hook into call 16 of table B (OutdatedPadGetButtons), which is called once per frame
-	void ** b0_tbl = GetB0Table();
-
-	// Insert call to real function
-	encode_j(install_addr + (&patch_vandal_return - &patch_vandal_start), b0_tbl[0x16]);
-
-	// Replace it now
-	b0_tbl[0x16] = install_addr;
-
-	// Advance installation address
-	return install_addr + (&patch_vandal_end - &patch_vandal_start);
-}
-
-uint8_t * install_fpb_patch(uint8_t * install_addr) {
-	// Exports defined by the patch
-	extern uint8_t patch_fpb_start;
-	extern uint8_t patch_fpb_end;
-
-	debug_write(" * FreePSXBoot");
-
-	// Copy blob
-	memcpy(install_addr, &patch_fpb_start, &patch_fpb_end - &patch_fpb_start);
-
-	// Install it
-	encode_jal((void *) 0x5B40, install_addr);
-
-	// Advance installation address
-	return install_addr + (&patch_fpb_end - &patch_fpb_start);
-}
-
-void patcher_apply(const char * boot_file) {
-	// We have plenty of space at the end of table B
-	uint8_t * install_addr = (uint8_t *) (GetB0Table() + 0x5E);
-
-	// Install patches
-	debug_write("Installing patches:");
-
-	// Install a suitable antimodchip patch
-	if (strcmp(boot_file, "cdrom:\\SLUS_009.40;1") == 0) {
-		install_addr = install_vandal_patch(install_addr);
-	} else {
-		install_addr = install_generic_antipiracy_patch(install_addr);
-	}
-
-	// FreePSXBoot does not work on PS2 so skip its installation
-	if (bios_is_ps1()) {
-		install_addr = install_fpb_patch(install_addr);
-	}
-}
-
-void patcher_apply_softuart() {
-	// Exports defined by the patch
-	extern uint8_t patch_uartputc_start;
-	extern uint8_t patch_uartputc_end;
-
-	// Overwrite BIOS' std_out_putchar function
-	memcpy(BIOS_A0_TABLE[0x3C], &patch_uartputc_start, &patch_uartputc_end - &patch_uartputc_start);
-}
diff --git a/tmp/og-tonyhax.Icq/loader/patcher.h b/tmp/og-tonyhax.Icq/loader/patcher.h
deleted file mode 100644
index 5b24f53..0000000
--- a/tmp/og-tonyhax.Icq/loader/patcher.h
+++ /dev/null
@@ -1,12 +0,0 @@
-
-#pragma once
-
-/**
- * Install and apply suitable BIOS patches.
- */
-void patcher_apply(const char * boot_file);
-
-/**
- * Installs the softUART patch.
- */
-void patcher_apply_softuart();
diff --git a/loader/secondary-ff9.ld b/loader/secondary-ff9.ld
new file mode 100644
index 0000000..e16567c
--- /dev/null
+++ b/loader/secondary-ff9.ld
@@ -0,0 +1,36 @@
+MEMORY {
+	ram(wrx)	:ORIGIN = 0x801F6300, LENGTH = 0x5E80
+}
+SECTIONS {
+	. = 0x801F6300;
+	PROVIDE(__RO_START__ = .);
+	.text :
+	{
+		*(.start)
+		*(.text .text.*)
+	} >ram
+	.rodata :
+	{
+		*(.rodata .rodata.*)
+	} >ram
+	.data :
+	{
+		*(.data .data.*)
+	} >ram
+	PROVIDE(__CRC_START__ = .);
+	.crc :
+	{
+		*(.crc .crc.*)
+	} >ram
+	PROVIDE(__BSS_START__ = .);
+	.bss :
+	{
+		*(.bss .bss.*)
+	} >ram
+	PROVIDE(__BSS_END__ = .);
+	/DISCARD/ :
+	{
+		*(*)
+	}
+}
+ENTRY (start)
diff --git a/tmp/og-tonyhax.Icq/loader/secondary.c b/loader/secondary.c
index 18a2cab..2db883e 100644
--- a/tmp/og-tonyhax.Icq/loader/secondary.c
+++ b/loader/secondary.c
@@ -10,13 +10,207 @@
 #include "crc.h"
 #include "debugscreen.h"
 #include "gpu.h"
-#include "patcher.h"
+#include "ap-bypass.h"
 #include "integrity.h"
 #include "io.h"
 
+uint8_t sscmd;
+uint8_t cdcontrollerver[4];
+
+const char * p5_localized;
+const char * region_name;
+
+bool calibrate_laser = 0; // Only Japanese VC2 and VC3 consoles need this so it is off by default
+bool bugged_setsession = 0; // VC0 A, VC0 B, and VC1 A CDROM Controller BIOS versions all have a buggy SetSession command that requires a special work around to use
+bool enable_unlock = 1; // Disabled on VC0A and VC0B Japanese CDROM Controller BIOS versions automatically. On VC1A+ the testregion command is run and if the region is Japan it is also disabled.
+bool controller_input = 0; // When enabled, debug_write does not display the repeat messages counter. This is so we can draw a blank line and then wait for controller input using vsync in debug_write.
+bool first_rev = 0; // VC0 A and VC0 B do not need any anti-piracy patching as they are immune to additional copy protection routines because of the lack of the ReadTOC command in the CDROM Controller BIOS Firmware.
+bool installed_cheat_engine = 0; // The cheat engine is installed when parse_memcard_save_gameshark_codes() completes. Some games may go on to set explicit anti-piracy bypass GameShark codes however, so to prevent the cheat engine from being installed twice (which is wasteful) we set a flag here.
+bool did_read_mc = 0; // We need to set the GameShark codes AFTER the last bios_reintialize(). I want to call bios_reinitilize() after reading the memory card data to prevent anything screwy in booting games, so we can just parse the data later after the final bios_reinitialize since it's still in RAM.
+bool controller_input_switch = 1; // modifies controller input pulling behavior in some functions later on
+uint8_t number_of_gameshark_code_lines; // part of my basic format to store codes, this tells us how many we will activate
+uint8_t * user_start = (uint8_t *) 0x80010000;
+uint16_t mc_base = 0x102; // start of gs code data in memcard buffer
+
 // Loading address of tonyhax, provided by the secondary.ld linker script
 extern uint8_t __RO_START__, __BSS_START__, __BSS_END__;
 
+// for controller input functions
+void * address;		// For Calculating BIOS Functions
+uint8_t j;			// Joypad
+uint8_t padbuf[2][0x22];	// Joypad Buffers
+
+
+//to test ROM functionality in emulation via boot CD, uncomment the following 2 lines:
+//#undef ROM
+//#define ROM
+
+//to test behavior without any APv2 bypasses enabled (useful for testing D0 AP bypass codes via save game file gameshark functionality rather then internal activate_anti_piracy() function), uncomment:
+//#define AP_BYPASS_DISABLE
+
+#if defined ROM
+void run_shell() {
+	// runs Sony BIOS. Can access CD Player/Memory Card Manager. Can not boot any discs, even ones that normally work without the flash cart inserted in the console. This has been adapted code from the SCPH-1001 decomp: https://github.com/ogamespec/psxdev/blob/97fbb2d03e5aff4449097afd2b59690002cb2341/reverse/Main.c#L395
+
+	debug_write("Starting Sony BIOS...");
+	memcpy((void*)0x80030000, (void*)0xBFC18000, 0x67FF0); // uses 0x80030000-0x80077FF0
+	FlushCache();
+	((void (*)(void))0x80030000)();
+}
+#endif
+
+void controller_input_start() {
+	controller_input = 1; // disable the repeat counter used in debug_write until controller input is done, see debugscreen.c
+	// BIOS Function InitPAD(buf1,sz1,buf2,sz2)
+	address = (uint32_t *) GetB0Table()[0x12];
+	((void (*)(uint8_t*,uint32_t,uint8_t*,uint32_t)) address)(padbuf[0],0x22,padbuf[1],0x22); // BIOS InitPAD(buf1,sz1,buf2,sz2) exec
+	// BIOS Function StartPAD()
+	address = (void *) (GetB0Table()[0x13]);
+	((void (*)(void)) address)();	// BIOS StartPad exec
+}
+
+void controller_input_stop() { // this doubles as 'closing' the memory card functions
+	controller_input = 0; // Set debug_write back to normal (enable repeat counter) as controller input is done
+	// BIOS Function StopPAD()
+	address = (void *) (GetB0Table()[0x14]);
+	// StopPAD() as we are done using Joypad input
+	((void (*)(void)) address)();	// BIOS StopPad exec
+}
+
+void read_memcard() {
+	debug_write("Reading MC...");
+	int32_t read;
+	// InitCard(pad_enable)
+	address = (uint32_t *) GetB0Table()[0x4A];
+	((void (*)(uint8_t*)) address)(0);
+	// BIOS FunctionStartCard()
+	address = (void *) (GetB0Table()[0x4B]);
+	((void (*)(void)) address)();
+	// BIOS Function _bu_init()
+	address = (void *) (GetB0Table()[0x55]);
+	((void (*)(void)) address)();
+	int32_t mc_fd = FileOpen("bu00:TONYHAXINTGS", FILE_READ);
+	if(mc_fd == -1) {
+		debug_write("Can not read MC");
+	}
+
+	if (mc_fd > 0) {
+		//bzero(user_start, 0x2000); // zero out mc buf
+		read = FileRead(mc_fd, user_start, 0x2000); // read the entire file "TONYHAXINTGS" to the start of 'user RAM' (which will be cleared later before booting an executable). So 0x80010000-0x80012000 in RAM contains the contents of "TONYHAXINTGS". 
+		
+		if (read == -1) {
+			debug_write("Read error %d", GetLastError());
+			return;
+		}
+
+		FileClose(mc_fd);
+		number_of_gameshark_code_lines = user_start[mc_base + 1];
+		debug_write("%d code lines detected", number_of_gameshark_code_lines);
+	}
+
+	controller_input_stop(); //restart so we can once again pull controller input
+
+	controller_input_start();
+
+	uint8_t sum;
+	uint8_t prev = 0;
+	uint8_t next;
+	uint8_t checksum_in_save_file = user_start[mc_base];
+
+	for (int i = 0x103; i < 0x2000; i++)
+	{
+		//debug_write("%x: @ %x", &user_start[i], user_start[i]);
+		next = user_start[i];
+		sum = prev + next;
+		sum &= 0xFF;
+		prev = sum;
+	}
+
+	if(checksum_in_save_file == sum) {
+		debug_write("Checksum: %x Verified", sum);
+		did_read_mc = 1; // set flag to parse codes uploaded to RAM, right before clearing RAM itself and booting the game
+	} else {
+		debug_write("Checksum: %x did not match! Can not read MC", sum);
+	}
+}
+
+void parse_memcard_save_gameshark_codes() {
+	/*
+	TONYHAXINTGS format:
+
+	0x00-0x101 = static save file data
+
+	0x102 = checksum generated by thigsgen
+
+	0x103 = number of code lines in hex
+
+	0x104-0x107 = gameshark code address (may or may not include code prefix i.e. D0, E0, 30, or 80 could be 0x104)
+
+	0x108-0x109 = gameshark code mod value
+		
+	0x110-0x103 = 2nd gameshark code address
+
+	0x114-0x115 = 2nd gameshark code mod value (and then so on and so on for number of code lines in hex number)
+	*/
+
+	uint32_t gameshark_code_address;
+	uint8_t gameshark_code_type;
+
+	/*
+	uint32_t sum;
+	uint8_t prev = 0;
+	uint8_t next;
+	for (int i = 0; i < 0x2000; i++)
+	{
+		debug_write("%x: @ %x", &user_start[i], user_start[i]);
+		next = user_start[i];
+		sum = prev + next;
+		sum &= 0xFF;
+		prev = sum;
+	}
+	debug_write("Memory card buffer checksum: %x", sum);
+	for (volatile int i = 0; i < 0x100000; i++);  // won't be optimized out by -Os, pause
+	*/
+
+	for(int i = 0; i < number_of_gameshark_code_lines; i++) {
+		
+		gameshark_code_type = user_start[mc_base + 5];
+			
+		if((gameshark_code_type == 0xD0) || (gameshark_code_type == 0xD1) || (gameshark_code_type == 0xE0) || (gameshark_code_type == 0xE1) || (gameshark_code_type == 0x30))
+			user_start[mc_base + 5] = 0x80; // we need to convert the prefix to the real address first byte of 0x80 for the cheat engine
+
+		gameshark_code_address = user_start[mc_base + 2] + (user_start[mc_base + 3] << 8) + (user_start[mc_base + 4] << 16) + (user_start[mc_base + 5] << 24);
+		//debug_write("GS Code Addr: %x", gameshark_code_address);
+
+		if(gameshark_code_type == 0x80) {
+			uint16_t gameshark_code_mod_val = user_start[mc_base + 6] + (user_start[mc_base + 7] << 8);
+			//debug_write("GS Code Mod Val: %x", gameshark_code_mod_val);
+			add_80_code(gameshark_code_address, gameshark_code_mod_val);
+		} else if(gameshark_code_type == 0xD0) {
+			uint16_t gameshark_code_mod_val = user_start[mc_base + 6] + (user_start[mc_base + 7] << 8);
+			//debug_write("GS Code Mod Val: %x", gameshark_code_mod_val);
+			add_D0_code(gameshark_code_address, gameshark_code_mod_val);
+		} else if(gameshark_code_type == 0xD1) {
+			uint16_t gameshark_code_mod_val = user_start[mc_base + 6] + (user_start[mc_base + 7] << 8);
+			//debug_write("GS Code Mod Val: %x", gameshark_code_mod_val);
+			add_D1_code(gameshark_code_address, gameshark_code_mod_val);
+		} else if(gameshark_code_type == 0x30) {
+			uint8_t gameshark_code_mod_val = user_start[mc_base + 6];
+			//debug_write("GS Code Mod Val: %x", gameshark_code_mod_val);
+			add_30_code(gameshark_code_address, gameshark_code_mod_val);
+		} else if(gameshark_code_type == 0xE0) {
+			uint8_t gameshark_code_mod_val = user_start[mc_base + 6];
+			//debug_write("GS Code Mod Val: %x", gameshark_code_mod_val);
+			add_E0_code(gameshark_code_address, gameshark_code_mod_val);
+		} else if(gameshark_code_type == 0xE1) {
+			uint8_t gameshark_code_mod_val = user_start[mc_base + 6];
+			//debug_write("GS Code Mod Val: %x", gameshark_code_mod_val);
+			add_E1_code(gameshark_code_address, gameshark_code_mod_val);
+		}
+		mc_base = (mc_base + 6); // advance 6 bytes from current val
+	}
+}
+
 void log_bios_version() {
 	/*
 	 * "System ROM Version 4.5 05/25/00 A"
@@ -31,7 +225,7 @@ void log_bios_version() {
 	}
 
 	debug_write("Console: %s", bios_is_ps1() ? "PS1": "PS2");
-	debug_write("BIOS: v%s", version);
+	debug_write("Sys BIOS: %s", version);
 }
 
 bool backdoor_cmd(uint_fast8_t cmd, const char * string) {
@@ -65,43 +259,6 @@ bool backdoor_cmd(uint_fast8_t cmd, const char * string) {
 }
 
 bool unlock_drive() {
-	uint8_t cd_reply[16];
-
-	// Run "GetRegion" test
-	uint8_t test = CD_TEST_REGION;
-	cd_command(CD_CMD_TEST, &test, 1);
-
-	// Should succeed with 3
-	if (cd_wait_int() != 3) {
-		debug_write("Region read failed");
-		return false;
-	}
-
-	// Read actual region text and null terminate it
-	int len = cd_read_reply(cd_reply);
-	cd_reply[len] = 0;
-
-	// Compare which is the fifth string we have to send to the backdoor
-	const char * region_name;
-	const char * p5_localized;
-	if (strcmp((char *) cd_reply, "for Europe") == 0) {
-		region_name = "European";
-		p5_localized = "(Europe)";
-	} else if (strcmp((char *) cd_reply, "for U/C") == 0) {
-		region_name = "American";
-		p5_localized = "of America";
-	} else if (strcmp((char *) cd_reply, "for NETEU") == 0) {
-		region_name = "NetYaroze (EU)";
-		p5_localized = "World wide";
-	} else if (strcmp((char *) cd_reply, "for NETNA") == 0) {
-		region_name = "NetYaroze (US)";
-		p5_localized = "World wide";
-	} else {
-		// +4 to skip past "for "
-		debug_write("Unsupported region: %s", (char *) (cd_reply + 4));
-		return false;
-	}
-
 	debug_write("Drive region: %s", region_name);
 
 	// Note the kernel's implementation of strlen returns 0 for nulls.
@@ -121,11 +278,46 @@ bool unlock_drive() {
 	return true;
 }
 
+#if !defined TOCPERFECT
 void wait_lid_status(bool open) {
 	uint8_t cd_reply[16];
+	
+	controller_input_start();
 
 	uint8_t expected = open ? 0x10 : 0x00;
 	do {
+
+		j = padbuf[0][3] ^ 0xFF;
+		debug_write(" "); // Vblank wait for controller input
+
+		if(controller_input_switch)
+		{
+#if defined ROM // this is more optimized for variable button presses then otherwise if we didn't test both statements in an else if
+			if(j == 0x40) { // X button
+				controller_input_stop();
+				run_shell(); // launch Sony BIOS
+			} else if(j == 0x20) { // Circle button
+				controller_input_switch = 0; // stop pulling for circle button input once we get it, as unlike the run_shell() function (which exits the program entirely) we still have to wait here until the user closes the console CD drive lid
+				read_memcard();
+			}
+#else // booting the shell is unnecessary for every other boot method besides the ROM so we don't include it
+			if(j == 0x20) { // Circle button
+				controller_input_switch = 0; // stop pulling for circle button input once we get it, as unlike the run_shell() function (which exits the program entirely) we still have to wait here until the user closes the console CD drive lid
+				read_memcard();
+			}
+#endif
+
+		#if defined ROM
+		} else { // still allow booting Sony BIOS after reading MC
+			if(j == 0x40) { // X button
+				controller_input_stop();
+				run_shell(); // launch Sony BIOS
+			}
+		}
+		#else
+		}
+		#endif
+
 		// Issue Getstat command
 		// We cannot issue the BIOS CD commands yet because we haven't called CdInit
 		cd_command(CD_CMD_GETSTAT, NULL, 0);
@@ -137,15 +329,152 @@ void wait_lid_status(bool open) {
 		cd_read_reply(cd_reply);
 
 	} while ((cd_reply[0] & 0x10) != expected);
+
+	controller_input_stop();
+}
+
+bool is_lid_open() {
+	uint8_t cd_reply[16];
+
+	// Issue Getstat command
+	// We cannot issue the BIOS CD commands yet because we haven't called CdInit
+	cd_command(CD_CMD_GETSTAT, NULL, 0);
+
+	// Always returns 3, no need to check
+	cd_wait_int();
+
+	// Always returns one, no need to check either
+	cd_read_reply(cd_reply);
+
+	if(cd_reply[0]==0x10) {
+		return true;
+	} else {
+		return false;
+	}   
+}
+
+bool licensed_drive() {
+	uint8_t getid_response[9];
+	unsigned char gid;
+
+	while(1) {
+    	cd_command(CD_CMD_GETID,0,0);
+		gid = cd_wait_int();
+		if(gid!=5)
+			break;
+	}
+	
+    cd_wait_int();
+	cd_read_reply(getid_response);
+
+	if(getid_response[0]==0x02 && getid_response[1]==0x00 && getid_response[2]==0x20 && getid_response[3]==0x00) {
+		return true;
+	} else {
+		return false;
+	}   
 }
+#endif
 
 void try_boot_cd() {
 	int32_t read;
+	uint8_t cbuf[4]; // CD Command Buffer
+
+	#if defined FREEPSXBOOT
+		debug_write("Remove the FreePSXBoot memory card now from your console");
+	#elif defined ROM
+		debug_write("With the CD drive open, press X to boot the Sony BIOS");
+	#endif
+
+	#if !defined TOCPERFECT
+		if(enable_unlock) {
+			debug_write("Press O to enable GS codes");
+			debug_write("Put in a backup or import disc, then close the drive lid");
+			wait_lid_status(true); // doesn't wait during the ROM method, unsure why but it is what we want as it allows us to auto-boot with the ROM boot method
+			wait_lid_status(false);
+		} else {
+			if(is_lid_open() || !licensed_drive()) {	// If lid is open drive is not licensed, and if lid is closed we check if it is licensed (if it is not licensed but not open then the drive is closed and the user can open it and license it)
+				debug_write("Put in a real NTSC-J PSX game disc, then block the lid sensor");
+				wait_lid_status(true);
+				wait_lid_status(false); // Blocking lid sensor = 'closing lid'
+
+	            debug_write("Initializing CD");	// Drive will be in licensed state after this is successful
+				if (!CdInit()) {
+					debug_write("Init failed");
+					debug_write("Try unblocking then blocking the lid sensor again");
+					return;
+				}
+			} // Drive is licensed and the lid is 'closed' at this point
+			debug_write("Drive is licensed");
+            
+			debug_write("Stopping motor");
+			cd_command(CD_CMD_STOP,0,0); cd_wait_int(); cd_wait_int();
+
+			debug_write("Press O to enable GS codes");
+			controller_input_start();
+
+			debug_write("Keep the lid sensor blocked until turning off the console");
+			debug_write("Remove the real NTSC-J PSX game disc");
+			debug_write("Put in a backup/import disc, then press X"); // Thanks MottZilla!
+            
+			while(1) { 
+				j = padbuf[0][3] ^ 0xFF;
+
+				if(controller_input_switch) {
+					if(j == 0x40) {
+						break; // X button boots disc
+					} else if(j == 0x20) { // Circle button enables codes
+						controller_input_switch = 0; // stop pulling for circle button input once we get it, as unlike when the X button is pressed (which breaks this loop) we still have to wait here until the user closes the console CD drive lid
+						read_memcard(); // this allows Japanese console users to enable user supplied GameShark codes without having to unblock the lid sensor, resetting authentication which would just be more unnecessary steps.
+					}
+				} else {
+					if(j == 0x40)
+						break; // X button boots disc
+				}
+				debug_write(" "); // Vblank wait for controller input
+			}
+		    controller_input_stop();
+		}
+	#endif
+
+	if(!enable_unlock) {
+		if(bugged_setsession) {
+			#if !defined STEALTH
+				debug_write("Sending SetSessionSuperUltraCommandSmash v2, please wait"); // always works on real hardware, DuckStation can get stuck here rarely though since it is not that accurate when it comes to emulating the early VC0A/VC0B/VC1A CDROM behavior
+			#endif
+			sscmd = 2; cd_command(CD_CMD_SET_SESSION,(unsigned char *)&sscmd,1); cd_wait_int(); cd_wait_int(); // There is a 3rd response we are ignoring by sending SetSession 1 next ASAP after SetSession 2.
+			sscmd = 1; cd_command(CD_CMD_SET_SESSION,(unsigned char *)&sscmd,1); cd_wait_int(); cd_wait_int();
+		} else {
+			#if !defined STEALTH
+				debug_write("Sending SetSession 1");
+			#endif
+			sscmd = 1; cd_command(CD_CMD_SET_SESSION,(unsigned char *)&sscmd,1); cd_wait_int(); cd_wait_int();
+		}
+
+		if(calibrate_laser) { // VC2 and VC3s do auto Bias/Gain calibration when reading a newly inserted real NTSC-J PS1 disc. A swapped in CD-R or just a different disc in general needs this to be updated
+        #if !defined STEALTH		
+        	debug_write("Calibrating laser");
+        #endif		
+        	cbuf[0] = 0x50; cbuf[1] = 0x38; cbuf[2] = 0x15; cbuf[3] = 0x0A;	// ModeCompensateTrackingAutoGain
+			cd_command(CD_CMD_TEST,&cbuf[0],4); 
+			cd_wait_int();
+		}
 
-	debug_write("Swap CD now");
-	wait_lid_status(true);
-	wait_lid_status(false);
+		/*
+		We have to re-initilize the BIOS, stop, and init in that order to prevent the process from possibly freezing at this point on Japanese consoles. 
+		
+		The first reason this is required is because the SetSessionSuperUltraCommandSmash screws up interrupts since we are sending the 2nd SetSession command before the possible 3rd interrupt (which is a second INT5 response sent if session 2 does not actually exist). 
+		
+		The second reason is because of how we are using the BIOS controller functions, to go back to a clean state a bios re-intialization also accomplishes that.
+		*/
 
+		debug_write("Reinitializing kernel"); 
+		bios_reinitialize();
+		bios_inject_disc_error();
+
+		debug_write("Stopping Motor");
+		cd_command(CD_CMD_STOP, NULL, 0); cd_wait_int(); cd_wait_int();
+	}
+	
 	debug_write("Initializing CD");
 	if (!CdInit()) {
 		debug_write("Init failed");
@@ -163,10 +492,17 @@ void try_boot_cd() {
 	uint8_t * data_buffer = (uint8_t *) (bios_is_ps1() ? 0xA000B070 : 0xA000A8D0);
 
 	debug_write("Checking game region");
-	if (CdReadSector(1, 4, data_buffer) != 1) {
-		debug_write("Failed to read sector");
-		return;
-	}
+    #if defined TOCPERFECT	
+    	if (CdReadSector(1, 12, data_buffer) != 1) { // Real license data sector is copied to sector 12 by PS1 DemoSwap Patcher before it writes Japanese license data to sector 4
+			debug_write("Failed to read sector");
+			return;
+		}
+	#else
+    	if (CdReadSector(1, 4, data_buffer) != 1) {
+			debug_write("Failed to read sector");
+			return;
+		}
+	#endif
 
 	const char * game_region;
 	bool game_is_pal = false;
@@ -203,9 +539,15 @@ void try_boot_cd() {
 	const char * bootfile = "cdrom:PSX.EXE;1";
 
 	char bootfilebuf[32];
-	debug_write("Loading SYSTEM.CNF");
 
-	int32_t cnf_fd = FileOpen("cdrom:SYSTEM.CNF;1", FILE_READ);
+	#if defined TOCPERFECT
+		debug_write("Loading SYSTEM.CN2");
+		int32_t cnf_fd = FileOpen("cdrom:SYSTEM.CN2;1", FILE_READ);
+	#else
+		debug_write("Loading SYSTEM.CNF");
+		int32_t cnf_fd = FileOpen("cdrom:SYSTEM.CNF;1", FILE_READ);
+	#endif
+    
 	if (cnf_fd > 0) {
 		read = FileRead(cnf_fd, data_buffer, 2048);
 		FileClose(cnf_fd);
@@ -241,6 +583,19 @@ void try_boot_cd() {
 	debug_write(" * %s = %x", "STACK", stacktop);
 	debug_write(" * %s = %s", "BOOT", bootfile);
 
+	debug_write("Reinitializing kernel"); 
+	bios_reinitialize();
+	bios_inject_disc_error();
+
+	debug_write("Stopping Motor"); // Reset one last time to avoid potential lockups (here be dragons)
+	cd_command(CD_CMD_STOP, NULL, 0); cd_wait_int(); cd_wait_int();
+	
+	debug_write("Initializing CD");
+	if (!CdInit()) {
+		debug_write("Init failed");
+		return;
+	}
+
 	/*
 	 * SetConf is run by BIOS with interrupts disabled.
 	 *
@@ -248,13 +603,18 @@ void try_boot_cd() {
 	 * the interrupt handler will store the current thread state in the zero address, wiping
 	 * vital data, like the interrupt trampoline at 0x80.
 	 */
+	
 	debug_write("Configuring kernel");
 	EnterCriticalSection();
 	SetConf(event, tcb, stacktop);
-	ExitCriticalSection();
+	ExitCriticalSection(); // unnecessary because SetConf() does this? Waiting on verdict from Socram8888: https://github.com/socram8888/tonyhax/issues/149
+
+	bzero((void*)0xD000, 0xF78); // 0xD000-0xDF78 are to be zeroed out to ensure correct parsing by the cheat engine (used for gs codes loaded via memcard AND for APv2 bypasses). 0xDF80 is used to contain BIOS patches so we stop 2 bytes previous to it. Every BIOS besides v3.0 has enough garbage in this 'reserved' area to break the cheat engine if we don't do this.
+
+	if(did_read_mc) // before clearing RAM (which contains our mem card buffer if applicable) but after last bios_reinitalize/setconf()
+		parse_memcard_save_gameshark_codes();
 
 	debug_write("Clearing RAM");
-	uint8_t * user_start = (uint8_t *) 0x80010000;
 	bzero(user_start, &__RO_START__ - user_start);
 
 	debug_write("Reading executable header");
@@ -271,6 +631,37 @@ void try_boot_cd() {
 		return;
 	}
 
+	/*
+	uint32_t sum;
+	uint8_t prev = 0;
+	uint8_t next;
+	uint8_t * ce = (uint8_t *) 0xC000;
+
+	for (int i = 0; i < 0x100; i++)
+	{
+		//debug_write("%x: @ %x", &ce[i], ce[i]);
+		next = ce[i];
+		sum = prev + next;
+		sum &= 0xFF;
+		prev = sum;
+	}
+	debug_write("Cheat engine checksum: %x", sum);
+	for (volatile int i = 0; i < 0x100000; i++);  // won't be optimized out by -Os, pause
+	
+	uint8_t * codes = (uint8_t *) 0xD000;
+
+	for (int i = 0; i < 0x1FFB; i++)
+	{
+		//debug_write("%x: @ %x", &codes[i], codes[i]);
+		next = codes[i];
+		sum = prev + next;
+		sum &= 0xFF;
+		prev = sum;
+	}
+	debug_write("Cheat engine enabled codes Checksum: %x", sum);
+	for (volatile int i = 0; i < 0x100000; i++);  // won't be optimized out by -Os, pause
+	*/
+
 	exe_header_t * exe_header = (exe_header_t *) (data_buffer + 0x10);
 
 	// If the file overlaps tonyhax, we will use the unstable LoadAndExecute function
@@ -286,6 +677,14 @@ void try_boot_cd() {
 		// Restore original error handler
 		bios_restore_disc_error();
 
+		#if !defined AP_BYPASS_DISABLE
+			if(!first_rev)
+				activate_anti_anti_piracy(bootfile, (int32_t) exe_header->load_addr);
+		#endif
+
+		if((did_read_mc) && (!cheat_engine_installed))
+			install_cheat_engine();
+
 		LoadAndExecute(bootfile, exe_header->initial_sp_base, exe_header->initial_sp_offset);
 		return;
 	}
@@ -299,8 +698,6 @@ void try_boot_cd() {
 
 	FileClose(exe_fd);
 
-	patcher_apply(bootfile);
-
 	if (game_is_pal != gpu_is_pal()) {
 		debug_write("Switching video mode");
 		debug_switch_standard(game_is_pal);
@@ -311,6 +708,14 @@ void try_boot_cd() {
 	// Restore original error handler
 	bios_restore_disc_error();
 
+	#if !defined AP_BYPASS_DISABLE
+		if(!first_rev)
+			activate_anti_anti_piracy(bootfile, (int32_t) exe_header->load_addr);
+	#endif
+
+	if((did_read_mc) && (!cheat_engine_installed))
+		install_cheat_engine();
+
 	// Games from WarmBoot start with interrupts disabled
 	EnterCriticalSection();
 
@@ -321,6 +726,7 @@ void try_boot_cd() {
 }
 
 void main() {
+	
 	// Undo all possible fuckeries during exploiting
 	bios_reinitialize();
 
@@ -337,24 +743,74 @@ void main() {
 
 	bios_inject_disc_error();
 	log_bios_version();
+    
+	debug_write("Resetting Drive");
+	cd_drive_init();
+
+	sscmd = 0x20; cd_command(CD_CMD_TEST,(unsigned char *)&sscmd,1); cd_wait_int(); 
+	cd_read_reply(cdcontrollerver);	// Test Command $19,$20 gets the CDROM BIOS
+	debug_write("CD BIOS: %x", *(uint32_t*) cdcontrollerver);
+   	if(cdcontrollerver[0]==0x94) {    
+        bugged_setsession = 1;
+        enable_unlock = 0; // VC0 A and VC0 B are both from 1994 and don't support the getregion command to figure out if it is unlockable or not.
+        first_rev = 1;
+    } 
+    else if(cdcontrollerver[1] == 0x05 && cdcontrollerver[2] == 0x16 && cdcontrollerver[0] == 0x95 && cdcontrollerver[3] == 0xC1) {     
+        bugged_setsession = 1; // NOTE I don't think this will ever be triggered but just in case. Earliest SCPH-3000s and late SCPH-1000s are VC0B and later SCPH-3000s are VC1B. Only unlockable systems have VC1A it seems.
+    }
+    else if((cdcontrollerver[3] == 0xC2) || (cdcontrollerver[3] == 0xC3)) {   
+        calibrate_laser = 1;
+    }
+
+	if(enable_unlock) {
+		uint8_t cd_reply[16];
+		// Run "GetRegion" test
+		uint8_t test = CD_TEST_REGION;
+		cd_command(CD_CMD_TEST, &test, 1);
+
+		// Should succeed with 3
+		if (cd_wait_int() != 3) {
+			debug_write("Region read failed");
+			return;
+		}
 
-	debug_write("Resetting drive");
-	if (!cd_drive_init()) {
-		debug_write("Reset failed");
-		return;
-	}
+		// Read actual region text and null terminate it
+		int len = cd_read_reply(cd_reply);
+		cd_reply[len] = 0;
+
+		// Compare which is the fifth string we have to send to the backdoor
+		if (strcmp((char *) cd_reply, "for Europe") == 0) {
+			region_name = "European";
+			p5_localized = "(Europe)";
+		} else if (strcmp((char *) cd_reply, "for U/C") == 0) {
+			region_name = "American";
+			p5_localized = "of America";
+		} else if (strcmp((char *) cd_reply, "for NETEU") == 0) {
+			region_name = "NetYaroze (EU)";
+			p5_localized = "World wide";
+		} else if (strcmp((char *) cd_reply, "for NETNA") == 0) {
+			region_name = "NetYaroze (US)";
+			p5_localized = "World wide";
+		} else if (strcmp((char *) cd_reply, "for Japan") == 0) {
+			enable_unlock = 0;
+		} else {
+			// +4 to skip past "for "
+			debug_write("Unsupported region: %s", (char *) (cd_reply + 4));
+			return;
+		}
 
-	debug_write("Unlocking drive");
-	if (!unlock_drive()) {
-		return;
+		if(enable_unlock) { // Check again, this could be false now
+			#if defined TOCPERFECT // Get TOC via reset + unlock instead of unlock + opening/closing the drive lid for auto loading in TOCPerfect, thanks MottZilla!
+				debug_write("Resetting drive");
+				cd_drive_reset();
+			#endif
+			debug_write("Unlocking drive");
+			if (!unlock_drive())
+				return;
+		}
 	}
 
 	while (1) {
-#if SOFTUART_PATCH
-		patcher_apply_softuart();
-		std_out_puts("SoftUART ready\n");
-#endif
-
 		try_boot_cd();
 
 		debug_write("Reinitializing kernel");
diff --git a/tmp/og-tonyhax.Icq/loader/secondary.ld b/loader/secondary.ld
index 7dc880a..3a91191 100644
--- a/tmp/og-tonyhax.Icq/loader/secondary.ld
+++ b/loader/secondary.ld
@@ -1,8 +1,8 @@
 MEMORY {
-	ram(wrx)	:ORIGIN = 0x801FA100, LENGTH = 0x3F00
+	ram(wrx)	:ORIGIN = 0x801F8180, LENGTH = 0x5E80
 }
 SECTIONS {
-	. = 0x801FA100;
+	. = 0x801F8180;
 	PROVIDE(__RO_START__ = .);
 	.text :
 	{
diff --git a/loader/tonyhax-tpl-ff9.mcs b/loader/tonyhax-tpl-ff9.mcs
new file mode 100644
index 0000000..660761e
Binary files /dev/null and b/loader/tonyhax-tpl-ff9.mcs differ
diff --git a/loader/tonyhax-tpl-old.mcs b/loader/tonyhax-tpl-old.mcs
new file mode 100644
index 0000000..50c3fa9
Binary files /dev/null and b/loader/tonyhax-tpl-old.mcs differ
diff --git a/tmp/og-tonyhax.Icq/loader/tonyhax-tpl.mcs b/loader/tonyhax-tpl.mcs
index 50c3fa9..ed08bc6 100644
Binary files a/tmp/og-tonyhax.Icq/loader/tonyhax-tpl.mcs and b/loader/tonyhax-tpl.mcs differ
